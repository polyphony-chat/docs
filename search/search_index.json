{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Polyphony","text":"<p>This documentation currently hosts information about polyproto; an advanced, secure and scalable protocol for federated chat services.</p> <p>The core of the protocol lies in the polyproto-core specification and in the federation API routes, which are used to negotiate and establish connections between foreign servers and clients.</p> <p>The polyproto-core federation protocol can be used for any kind of online service, enabling you to bring federated identities to your federated social network, federated chat service or federated $ANYTHING.</p>"},{"location":"#glossary","title":"Glossary","text":"<ul> <li>Actor - An entity represented by a federation ID, registered on a home server. Actors can be users, bots, or any other entity with an identity.</li> <li>Client - Any application used by an actor to connect to a server.</li> <li>Federation ID - A unique identifier; In public contexts, usually <code>username@optionalsubdomain.domain.tld</code></li> <li>Foreign client - Any client authenticated on a server that is not its home server.</li> <li>Foreign server - A server that an actor is not registered on; essentially a third party.</li> <li>Home client - Any client registered and authenticated on its home server.</li> <li>Home server - The server that an actor is registered on. Any polyproto-core compliant server hosted on the same domain is also considered a home server.</li> <li>Identity - A unique Federation ID.</li> <li>Identity Key - A key pair representing an actor's identity in a session, used for signing and encrypting messages.</li> <li>Instance - A server hosting polyproto compliant software for clients.</li> <li>polyproto-chat - The chat-API used by Polyphony. An extension of the polyproto protocol, defining the routes and capabilities of the chat-API used by Polyphony.</li> <li>polyproto - The core federation protocol and APIs of polyproto, enabling identification and authorization on 'foreign' servers. It is independent of the chat-API used.</li> <li>Root Certificate - A certificate used to sign other certificates, establishing a chain of trust. In polyproto, only home servers have root certificates.</li> <li>Session - A specific period of interaction between a client and a server, typically identified and authenticated by the use of an identity key. The session begins when the client connects to the server and ends when the client disconnects. During a session, the client can interact with the server (e.g., send messages, make requests) under the identity associated with the session.</li> </ul>"},{"location":"APIs/","title":"APIs","text":"<p>TODO: Add content</p>"},{"location":"APIs/Core/errors/","title":"Errors","text":"<p>TODO</p>"},{"location":"APIs/Core/errors/#error-codes","title":"Error Codes","text":"<p>TODO</p>"},{"location":"APIs/Core/errors/#p2core_federation_id_taken","title":"P2CORE_FEDERATION_ID_TAKEN","text":"<p>TODO</p>"},{"location":"APIs/Core/errors/#p2core_session_id_taken","title":"P2CORE_SESSION_ID_TAKEN","text":"<p>TODO</p>"},{"location":"APIs/Core/rate-limits/","title":"Rate limits","text":"<p>TODO</p>"},{"location":"APIs/Core/types/","title":"Types","text":"<p>Type definitions required for using the polyproto-core API.</p>"},{"location":"APIs/Core/types/#event","title":"Event","text":"<p>TODO</p>"},{"location":"APIs/Core/types/#snowflake","title":"Snowflake","text":"<p>TODO</p>"},{"location":"APIs/Core/types/#federation-id","title":"Federation ID","text":"<p>TODO</p>"},{"location":"APIs/Core/types/#challenge-string","title":"Challenge String","text":"<p>TODO</p>"},{"location":"APIs/Core/types/#completed-challenge-string","title":"Completed Challenge String","text":"<p>TODO</p>"},{"location":"APIs/Core/types/#public-user-profile","title":"Public User Profile","text":"<p>TODO</p>"},{"location":"APIs/Core/Routes%3A%20No%20registration%20needed/","title":"Client-Foreign Server API Routes","text":"<p>All API endpoints needed for Client-Home Server communication. This Page only includes routes, for which a client does not need a \"Client-Home Server relationship\" with the server. Routes explicitly requiring a Client-&gt;Home Server relationship are documented here</p> <p>Unfinished section</p> <p>TODO: This section is not yet finished. It is missing descriptions for most routes, some error-code responses, etc.</p>"},{"location":"APIs/Core/Routes%3A%20No%20registration%20needed/#authorization","title":"Authorization","text":"<p>Bearer token, unless specified otherwise.</p>"},{"location":"APIs/Core/Routes%3A%20No%20registration%20needed/#errors","title":"Errors","text":"<p>The errors listed below are not exhaustive, and only include the most common errors associated with an endpoint. For rate limit errors, see the Rate Limits documentation.</p>"},{"location":"APIs/Core/Routes%3A%20No%20registration%20needed/#authentication","title":"Authentication","text":"<p>Routes concerning authentication.</p>"},{"location":"APIs/Core/Routes%3A%20No%20registration%20needed/#post-create-identity","title":"POST Create Identity","text":"<p><code>/p2core/register</code></p> <p>Creates an identity on a given server.</p>"},{"location":"APIs/Core/Routes%3A%20No%20registration%20needed/#request","title":"Request","text":""},{"location":"APIs/Core/Routes%3A%20No%20registration%20needed/#body","title":"Body","text":"<p>TODO: Re-evaluate if <code>auth_payload</code> is needed here.</p> Name Type Description <code>actor_name</code> String The preferred name for this new identity. <code>password</code> String The password for this new identity. <code>auth_payload</code> JSON-Object n. A. JSON<pre><code>{\n    \"actor_name\": \"alice\",\n    \"password\": \"s3cr3t\",\n    \"auth_payload\": {\n        \"email\": \"alice@example.com\"\n    }\n}\n</code></pre>"},{"location":"APIs/Core/Routes%3A%20No%20registration%20needed/#response","title":"Response","text":"201 Created409 Conflict <p>Returned when the requested actor name is already taken within the namespace.</p>"},{"location":"APIs/Core/Routes%3A%20No%20registration%20needed/#body_1","title":"Body","text":"Name Type Description <code>fid</code> String The Federation ID of the new identity. <code>payload</code> JSON-Object n.A. JSON<pre><code>{\n    \"fid\": \"xenia@example.com\",\n    \"payload\": {\n        \"some_account_information\": \"important information\",\n        \"is_awesome\": true\n    }\n}\n</code></pre>"},{"location":"APIs/Core/Routes%3A%20No%20registration%20needed/#body_2","title":"Body","text":"JSON<pre><code>{\n    \"errcode\": 409,\n    \"error\": \"P2CORE_FEDERATION_ID_TAKEN\"\n}\n</code></pre>"},{"location":"APIs/Core/Routes%3A%20No%20registration%20needed/#get-challenge-string","title":"GET Challenge string","text":"<p><code>/p2core/challenge</code></p> <p>Request a challenge string. See the type definition or the corresponding protocol definition chapter for more information.</p>"},{"location":"APIs/Core/Routes%3A%20No%20registration%20needed/#request_1","title":"Request","text":""},{"location":"APIs/Core/Routes%3A%20No%20registration%20needed/#body_3","title":"Body","text":"Name Type Description <code>session_id</code> String The session ID of the session for which the challenge should be generated. JSON<pre><code>{\n    \"session_id\": \"G5a6hjv2ijcnr3ghjHV74jahUH675678rbnFGNHJV...\"\n}\n</code></pre>"},{"location":"APIs/Core/Routes%3A%20No%20registration%20needed/#response_1","title":"Response","text":"Text Only<pre><code>=== \"200 OK\"\n\n##### Body\n\n| Name            | Type   | Description                                                                                                       |\n| --------------- | ------ | ----------------------------------------------------------------------------------------------------------------- |\n| `challenge`     | String | The [challenge string](../types.md#challenge-string), which the client should sign with its private identity key. |\n| `lifetime_unix` | String | The UNIX timestamp after which the challenge expires.                                                             |\n\n```json\n{\n    \"challenge\": \"UH675678rbnFGNHJV2ijcnr3ghjHV74jah...\",\n    \"lifetime_unix\": \"1620000000\"\n}\n```\n</code></pre>"},{"location":"APIs/Core/Routes%3A%20No%20registration%20needed/#post-identify","title":"POST Identify","text":"<p><code>/p2core/session/identify</code></p> <p>Identify on a foreign server and receive a session token.</p>"},{"location":"APIs/Core/Routes%3A%20No%20registration%20needed/#request_2","title":"Request","text":""},{"location":"APIs/Core/Routes%3A%20No%20registration%20needed/#body_4","title":"Body","text":"Name Type Description <code>challenge</code> String The completed challenge string, signed with the client's private identity key. <code>id_cert</code> String, PEM, Base64 The client's ID-Cert, encoded in PEM &amp; Base64. <code>auth_payload</code> JSON-Object n. A. JSON<pre><code>{\n    \"completed_challenge\": {\n        \"challenge\": \"UH675678rbnFGNHJV2ijcnr3ghjHV74jah...\",\n        \"signature\": \"Ac4hjv2ijcnr3ghjHV74jahUH675678rbnFGNHJV...\"\n    },\n    \"id_cert\": \"gA3hjv2ijcnr3ghjHV74jahUH675678rbnFGNHJV...\",\n    \"auth_payload\": {\n        \"my_custom_attribute\": \"my_custom_value\"\n    }\n}\n</code></pre>"},{"location":"APIs/Core/Routes%3A%20No%20registration%20needed/#response_2","title":"Response","text":"201 Created"},{"location":"APIs/Core/Routes%3A%20No%20registration%20needed/#body_5","title":"Body","text":"Name Type Description <code>token</code> String A session token, to be used for further identification/authentication <code>payload</code> JSON-Object n.A. JSON<pre><code>{\n    \"token\": \"G5a6hjv2ijcnr3ghjHV74jahUH675678rbnFGNHJV...\",\n    \"payload\": {\n        \"my_custom_response_attribute\": \"my_custom_response_value\"\n    }\n}\n</code></pre>"},{"location":"APIs/Core/Routes%3A%20No%20registration%20needed/#put-revoke-session-authentication","title":"PUT Revoke session authentication","text":"<p><code>/p2core/session/revoke</code></p> <p>Revoke the current session's authentication by having the server invalidate the session token. Can also be seen as a \"logout\" operation.</p>"},{"location":"APIs/Core/Routes%3A%20No%20registration%20needed/#request_3","title":"Request","text":""},{"location":"APIs/Core/Routes%3A%20No%20registration%20needed/#body_6","title":"Body","text":"<p>This request has no body.</p>"},{"location":"APIs/Core/Routes%3A%20No%20registration%20needed/#response_3","title":"Response","text":"204 No Content"},{"location":"APIs/Core/Routes%3A%20No%20registration%20needed/#body_7","title":"Body","text":"<p>This response has no body.</p>"},{"location":"APIs/Core/Routes%3A%20No%20registration%20needed/#federated-identity","title":"Federated Identity","text":"<p>Routes concerning federated identities, such as authentication and ID-Cert management.</p>"},{"location":"APIs/Core/Routes%3A%20No%20registration%20needed/#put-rotate-server-identity-key","title":"PUT Rotate Server Identity Key","text":"<p><code>/p2core/key/server</code></p> <p>Rotate the server's identity key.</p>"},{"location":"APIs/Core/Routes%3A%20No%20registration%20needed/#request_4","title":"Request","text":""},{"location":"APIs/Core/Routes%3A%20No%20registration%20needed/#body_8","title":"Body","text":"<p>This request has no body.</p>"},{"location":"APIs/Core/Routes%3A%20No%20registration%20needed/#response_4","title":"Response","text":"200 OK"},{"location":"APIs/Core/Routes%3A%20No%20registration%20needed/#body_9","title":"Body","text":"Type Description String The servers' new public identity key, in ASCII-representation. JSON<pre><code>\"-----BEGIN PGP PUBLIC KEY BLOCK-----\nmQINBGSDs58BEADCXP1ArorBtOvGnQdAD26gsOMasyLMqnJyUp8XXCdmTx5+gREs\nvtItmjIshHU6CLUyTwO2IqIb2Fds+AmDsdM1Qx/vM0fVtPAS13T3Tu9rknldJvvN\nGyT3urrgvZ1leqQnwvuHd3WMdtgQ29lc7F/XaP4v2RIlqUiV+bnBoe/6LL7HXTaW\nzy2oKXr/odOD4+476J5APxxXCWVLXr3qfAXmSBQERznYuuRmhyL...\n-----END PGP PUBLIC KEY BLOCK-----\"\n</code></pre>"},{"location":"APIs/Core/Routes%3A%20No%20registration%20needed/#get-server-public-identity-key","title":"GET Server Public Identity Key","text":"<p><code>/p2core/key/server</code></p> <p>Request the server's public identity key.</p>"},{"location":"APIs/Core/Routes%3A%20No%20registration%20needed/#request_5","title":"Request","text":""},{"location":"APIs/Core/Routes%3A%20No%20registration%20needed/#body_10","title":"Body","text":"Name Type Description <code>timestamp</code> String UNIX-Timestamp. If specified, the server will return the ID-Cert which it had at the specified time JSON<pre><code>{\n    \"timestamp\": \"1620000000\"\n}\n</code></pre>"},{"location":"APIs/Core/Routes%3A%20No%20registration%20needed/#response_5","title":"Response","text":"200 OK"},{"location":"APIs/Core/Routes%3A%20No%20registration%20needed/#body_11","title":"Body","text":"Text Only<pre><code>| Type             | Description                                                    |\n| ---------------- | -------------------------------------------------------------- |\n| String, PEM, Base64  | The servers' public [ID-Cert](/Protocol%20Specifications/core/#71-home-server-signed-certificates-for-public-client-identity-keys-id-cert).     |\n\n```json\n[...]\n```\n</code></pre>"},{"location":"APIs/Core/Routes%3A%20No%20registration%20needed/#get-actor-id-certs","title":"GET Actor ID-Cert(s)","text":"<p><code>/p2core/key/actor/:fid</code></p> <p>Request the ID-Certs of a specific actor. The specified actor must be registered on this server.</p>"},{"location":"APIs/Core/Routes%3A%20No%20registration%20needed/#request_6","title":"Request","text":""},{"location":"APIs/Core/Routes%3A%20No%20registration%20needed/#parameters","title":"Parameters","text":"Name Type Description <code>fid</code> String, Federation ID The ID of the actor whose ID-Cert(s) should be returned."},{"location":"APIs/Core/Routes%3A%20No%20registration%20needed/#body_12","title":"Body","text":"Name Type Description <code>timestamp</code> String UNIX-Timestamp. If specified, the server will return the ID-Cert(s) which the actor had at the specified time <code>session_id</code> String Request the ID-Cert for a specific session ID. JSON<pre><code>{\n    \"timestamp\": \"1620000000\",\n    \"session_id\": \"593b30d8-0c98-4393-9331-988281b46782\"\n}\n</code></pre>"},{"location":"APIs/Core/Routes%3A%20No%20registration%20needed/#response_6","title":"Response","text":"200 OK"},{"location":"APIs/Core/Routes%3A%20No%20registration%20needed/#body_13","title":"Body","text":"Type Description JSON-Array of Strings (PEM, Base64) The actor's public identity certificate(s), encoded in PEM (Base64). JSON<pre><code>[...]\n</code></pre>"},{"location":"APIs/Core/Routes%3A%20No%20registration%20needed/#post-update-session-id-cert","title":"POST Update session ID-Cert","text":"<p><code>/p2core/session/idcert/extern</code></p> <p>Lets a foreign server know that the ID-Cert of this session has changed.</p>"},{"location":"APIs/Core/Routes%3A%20No%20registration%20needed/#request_7","title":"Request","text":""},{"location":"APIs/Core/Routes%3A%20No%20registration%20needed/#body_14","title":"Body","text":"Type Description String, PEM, Base64 The new ID-Cert for this session ID. JSON<pre><code>[...]\n</code></pre>"},{"location":"APIs/Core/Routes%3A%20No%20registration%20needed/#response_7","title":"Response","text":"201 Created"},{"location":"APIs/Core/Routes%3A%20No%20registration%20needed/#body_15","title":"Body","text":"<p>This response has no body.</p>"},{"location":"APIs/Core/Routes%3A%20No%20registration%20needed/#encryption","title":"Encryption","text":"<p>Client-Foreign Server API endpoints concerned with encryption related tasks.</p>"},{"location":"APIs/Core/Routes%3A%20No%20registration%20needed/#get-keypackages","title":"GET KeyPackage(s)","text":"<p><code>/p2core/keypackage/:fid</code></p> <p>Request KeyPackages - initial encryption keying material - for a specific actor from the server. The requested actor must be registered on this server.</p>"},{"location":"APIs/Core/Routes%3A%20No%20registration%20needed/#request_8","title":"Request","text":""},{"location":"APIs/Core/Routes%3A%20No%20registration%20needed/#parameters_1","title":"Parameters","text":"Name Type Description <code>fid</code> String, Federation ID The Federation ID of the actor whose KeyPackage(s) should be returned."},{"location":"APIs/Core/Routes%3A%20No%20registration%20needed/#body_16","title":"Body","text":"<p>This request has no body.</p>"},{"location":"APIs/Core/Routes%3A%20No%20registration%20needed/#response_8","title":"Response","text":"200 OK"},{"location":"APIs/Core/Routes%3A%20No%20registration%20needed/#body_17","title":"Body","text":"Type Description JSON-Array of KeyPackage(s), Base64 The actor's KeyPackage(s), Base64 encoded. Each entry in the array corresponds to a different client the requested actor is authenticated on. JSON<pre><code>[...]\n</code></pre>"},{"location":"APIs/Core/Routes%3A%20No%20registration%20needed/#other","title":"Other","text":"<p>Routes not fitting into another category.</p>"},{"location":"APIs/Core/Routes%3A%20No%20registration%20needed/#get-events","title":"GET Events","text":"<p><code>/p2core/events</code></p> <p>Fetch Gateway events via REST.</p>"},{"location":"APIs/Core/Routes%3A%20No%20registration%20needed/#request_9","title":"Request","text":""},{"location":"APIs/Core/Routes%3A%20No%20registration%20needed/#body_18","title":"Body","text":"<p>This request has no body.</p>"},{"location":"APIs/Core/Routes%3A%20No%20registration%20needed/#response_9","title":"Response","text":"200 OK409 No Content <p>Returned if there are no events to inform the client about.</p>"},{"location":"APIs/Core/Routes%3A%20No%20registration%20needed/#body_19","title":"Body","text":"Type Description JSON-Array of Events All WebSocket Events this session has missed since disconnecting from the WebSocket, or since last querying this endpoint."},{"location":"APIs/Core/Routes%3A%20No%20registration%20needed/#body_20","title":"Body","text":"<p>This response has no body.</p>"},{"location":"APIs/Core/Routes%3A%20No%20registration%20needed/#glossary","title":"Glossary","text":"<ul> <li>Actor - An entity represented by a federation ID, registered on a home server. Actors can be users, bots, or any other entity with an identity.</li> <li>Client - Any application used by an actor to connect to a server.</li> <li>Federation ID - A unique identifier; In public contexts, usually <code>username@optionalsubdomain.domain.tld</code></li> <li>Foreign client - Any client authenticated on a server that is not its home server.</li> <li>Foreign server - A server that an actor is not registered on; essentially a third party.</li> <li>Home client - Any client registered and authenticated on its home server.</li> <li>Home server - The server that an actor is registered on. Any polyproto-core compliant server hosted on the same domain is also considered a home server.</li> <li>Identity - A unique Federation ID.</li> <li>Identity Key - A key pair representing an actor's identity in a session, used for signing and encrypting messages.</li> <li>Instance - A server hosting polyproto compliant software for clients.</li> <li>polyproto-chat - The chat-API used by Polyphony. An extension of the polyproto protocol, defining the routes and capabilities of the chat-API used by Polyphony.</li> <li>polyproto - The core federation protocol and APIs of polyproto, enabling identification and authorization on 'foreign' servers. It is independent of the chat-API used.</li> <li>Root Certificate - A certificate used to sign other certificates, establishing a chain of trust. In polyproto, only home servers have root certificates.</li> <li>Session - A specific period of interaction between a client and a server, typically identified and authenticated by the use of an identity key. The session begins when the client connects to the server and ends when the client disconnects. During a session, the client can interact with the server (e.g., send messages, make requests) under the identity associated with the session.</li> </ul>"},{"location":"APIs/Core/Routes%3A%20Registration%20needed/","title":"Client-Home Server API Routes","text":"<p>All API endpoints needed for Client-Home Server communication. This Page only includes routes which a client can request from its home server. For routes which can also be accessed from a foreign server, or with no authentication at all, see the Client-Foreign Server API documentation</p> <p>Unfinished section</p> <p>TODO: This section is not yet finished. It is missing descriptions for most routes, some error-code responses, etc.</p>"},{"location":"APIs/Core/Routes%3A%20Registration%20needed/#authorization","title":"Authorization","text":"<p>Bearer token, unless specified otherwise.</p>"},{"location":"APIs/Core/Routes%3A%20Registration%20needed/#errors","title":"Errors","text":"<p>The errors listed below are not exhaustive, and only include the most common errors associated with an endpoint. For rate limit errors, see the Rate Limits documentation.</p>"},{"location":"APIs/Core/Routes%3A%20Registration%20needed/#authentication","title":"Authentication","text":"<p>Authentication endpoints, such as creating an identity and authenticating a client with an identity.</p>"},{"location":"APIs/Core/Routes%3A%20Registration%20needed/#post-authenticate-new-session","title":"POST Authenticate new Session","text":"<p><code>/p2core/session/trust</code></p> <p>Creates a new <code>id_cert</code> and a session token from a <code>csr</code>.</p>"},{"location":"APIs/Core/Routes%3A%20Registration%20needed/#request","title":"Request","text":""},{"location":"APIs/Core/Routes%3A%20Registration%20needed/#body","title":"Body","text":"Name Type Description <code>actor_name</code> String The actor name of the identity to authenticate as. <code>csr</code> String, Base64 A certificate signing request (CSR) <code>password</code> String The password for this identity. <code>auth_payload</code> JSON-Object n. A."},{"location":"APIs/Core/Routes%3A%20Registration%20needed/#response","title":"Response","text":"201 Created"},{"location":"APIs/Core/Routes%3A%20Registration%20needed/#body_1","title":"Body","text":"Name Type Description <code>id_cert</code> String, Base64 The ID-Cert for this unique Identity-Session combination <code>token</code> String An authorization secret, called a \"token\", valid for this <code>id_cert</code>."},{"location":"APIs/Core/Routes%3A%20Registration%20needed/#federated-identity","title":"Federated Identity","text":"<p>Client-Home Server API endpoints concerned with Federated Identity and managing ID-Certs.</p>"},{"location":"APIs/Core/Routes%3A%20Registration%20needed/#post-rotate-session-id-cert","title":"POST Rotate session ID-Cert","text":"<p><code>/p2core/session/idcert</code></p> <p>Rotate your keys for a given ID-Cert. The <code>session_id</code> in the supplied <code>csr</code> must correspond to the session token used in the <code>authorization</code>-Header.</p>"},{"location":"APIs/Core/Routes%3A%20Registration%20needed/#request_1","title":"Request","text":""},{"location":"APIs/Core/Routes%3A%20Registration%20needed/#body_2","title":"Body","text":"Name Type Description <code>csr</code> String, Base64 A certificate signing request (CSR) containing a new public key for this session ID. JSON<pre><code>{\n    \"csr\": \"mQINBGSDs58BEADCXP1ArorBtOvGnQdAD26gsOMasyLMqnJyUp8XXCdmTx5...\"\n}\n</code></pre>"},{"location":"APIs/Core/Routes%3A%20Registration%20needed/#response_1","title":"Response","text":"201 Created <p>Contains your new ID-Cert, along with a new session token.</p>"},{"location":"APIs/Core/Routes%3A%20Registration%20needed/#body_3","title":"Body","text":"Name Type Description <code>id_cert</code> String, Base64 The generated ID-Cert. <code>token</code> String An authorization secret, called a \"token\", valid for this <code>id_cert</code>. JSON<pre><code>{ \n    \"id_cert\": \"LS0tLS1CRUdJTiBQR1AgUFVCTElDIEtFWS0tLS0tCk1JSUJqRENDQWlNQ0NRRHdFTE1Ba0dBMVVFQ2d3R2FWTnZiV0ZwYm...\",\n    \"token\": \"Afnaopgi7BXVafjkl34ulvkc...\"\n}\n</code></pre>"},{"location":"APIs/Core/Routes%3A%20Registration%20needed/#encryption","title":"Encryption","text":"<p>Client-Home Server API endpoints concerned with encryption, such as KeyPackage management.</p>"},{"location":"APIs/Core/Routes%3A%20Registration%20needed/#post-add-keypackage","title":"POST Add KeyPackage","text":"<p><code>/p2core/keypackage/@me</code></p> <p>Add a KeyPackage to your KeyPackage store on the server. Only adds KeyPackages to the ID-Cert corresponding to the session token used in the <code>authorization</code>-Header.</p>"},{"location":"APIs/Core/Routes%3A%20Registration%20needed/#request_2","title":"Request","text":""},{"location":"APIs/Core/Routes%3A%20Registration%20needed/#body_4","title":"Body","text":"Type Description JSON-Array of KeyPackages One or more KeyPackages to add to the available KeyPackages for this actor. JSON<pre><code>[ {...}, {...} ]\n</code></pre>"},{"location":"APIs/Core/Routes%3A%20Registration%20needed/#response_2","title":"Response","text":"201 Created"},{"location":"APIs/Core/Routes%3A%20Registration%20needed/#body_5","title":"Body","text":"<p>This response has no body.</p>"},{"location":"APIs/Core/Routes%3A%20Registration%20needed/#put-replace-last-resort-keypackage","title":"PUT Replace Last Resort KeyPackage","text":"<p><code>/p2core/keypackage_lr</code></p> <p>Replace a Last Resort KeyPackage with a new one. Only manipulates Last Resort KeyPackages for the ID-Cert corresponding to the session token used in the <code>authorization</code>-Header.</p>"},{"location":"APIs/Core/Routes%3A%20Registration%20needed/#request_3","title":"Request","text":""},{"location":"APIs/Core/Routes%3A%20Registration%20needed/#body_6","title":"Body","text":"Type Description KeyPackage The KeyPackage to replace the current Last Resort KeyPackage with. JSON<pre><code>{...}\n</code></pre>"},{"location":"APIs/Core/Routes%3A%20Registration%20needed/#response_3","title":"Response","text":"204 No Content"},{"location":"APIs/Core/Routes%3A%20Registration%20needed/#body_7","title":"Body","text":"<p>This response has no body.</p>"},{"location":"APIs/Core/Routes%3A%20Registration%20needed/#glossary","title":"Glossary","text":"<ul> <li>Actor - An entity represented by a federation ID, registered on a home server. Actors can be users, bots, or any other entity with an identity.</li> <li>Client - Any application used by an actor to connect to a server.</li> <li>Federation ID - A unique identifier; In public contexts, usually <code>username@optionalsubdomain.domain.tld</code></li> <li>Foreign client - Any client authenticated on a server that is not its home server.</li> <li>Foreign server - A server that an actor is not registered on; essentially a third party.</li> <li>Home client - Any client registered and authenticated on its home server.</li> <li>Home server - The server that an actor is registered on. Any polyproto-core compliant server hosted on the same domain is also considered a home server.</li> <li>Identity - A unique Federation ID.</li> <li>Identity Key - A key pair representing an actor's identity in a session, used for signing and encrypting messages.</li> <li>Instance - A server hosting polyproto compliant software for clients.</li> <li>polyproto-chat - The chat-API used by Polyphony. An extension of the polyproto protocol, defining the routes and capabilities of the chat-API used by Polyphony.</li> <li>polyproto - The core federation protocol and APIs of polyproto, enabling identification and authorization on 'foreign' servers. It is independent of the chat-API used.</li> <li>Root Certificate - A certificate used to sign other certificates, establishing a chain of trust. In polyproto, only home servers have root certificates.</li> <li>Session - A specific period of interaction between a client and a server, typically identified and authenticated by the use of an identity key. The session begins when the client connects to the server and ends when the client disconnects. During a session, the client can interact with the server (e.g., send messages, make requests) under the identity associated with the session.</li> </ul>"},{"location":"APIs/Core/WebSockets/","title":"Index","text":"<p>TODO</p>"},{"location":"APIs/Core/WebSockets/gateway/","title":"Gateway","text":"<p>TODO</p>"},{"location":"APIs/Core/WebSockets/gateway_events/","title":"Gateway Events","text":"<p>TODO</p>"},{"location":"APIs/Core/WebSockets/gateway_events/#client_key_change","title":"<code>CLIENT_KEY_CHANGE</code>","text":"<p>TODO</p>"},{"location":"APIs/Core/WebSockets/gateway_events/#server_key_change","title":"<code>SERVER_KEY_CHANGE</code>","text":"<p>TODO</p>"},{"location":"APIs/Core/WebSockets/gateway_events/#low_key_packages","title":"<code>LOW_KEY_PACKAGES</code>","text":"<p>TODO</p>"},{"location":"APIs/Core/WebSockets/gateway_events/#new_session","title":"<code>NEW_SESSION</code>","text":"<p>TODO</p>"},{"location":"Overviews/core/","title":"An Overview of polyproto","text":"<p>Work in Progress</p> <p>This overview page is not yet finished. However, that what is there is already representative of what the polyproto protocol is about.</p> <p>polyproto is a federated identity and message exchange protocol, which can be used for almost anything. If you'd like to build an application where federation, user control and data integrity are wanted, then polyproto is most likely for you. Read this overview to get to know the core concepts and technologies used in the protocol. </p>"},{"location":"Overviews/core/#identity","title":"Identity","text":"<p>Your identity is always represented by a Federation ID, FID for short. Conceptually, FIDs are nothing new, and they look like this: </p> <p><code>xenia@some.example.com</code></p> <p>Everything after the <code>@</code> is your Home Servers' domain, and the part before the <code>@</code> is your username. Together, this makes for an individual, yet globally unique identifier.</p>"},{"location":"Overviews/core/#certificates-and-keys","title":"Certificates and Keys","text":"<p>Identity Certificates - ID-Certs for short - represent your identity when logged in on different sessions. Each Identity Certificate contains the following information:</p> <ul> <li>Your federation ID, so that an account can be uniquely identified</li> <li>A session ID, which is unique for each session and does not change, even if the keys change</li> <li>An expiry date, after which the certificate becomes invalid</li> <li>A signature, generated by your home server, which acts as part of the proof that this certificate was   actually issued by your home server</li> <li>Some information from your home server (Home server domain, certificate serial number)</li> <li>Information about the signature algorithm used</li> </ul> <p>and, last but not least</p> <ul> <li>The public identity key of the client</li> </ul> <p>For the sake of explanation, the most important parts here are the client public identity key, your federation ID, the home servers' domain and the home servers' signature for this certificate.</p>"},{"location":"Overviews/core/#message-signing","title":"Message signing","text":"<p>When you, for example, chat with someone on a different server, that other server is fully in control about what data it chooses to present to you. To make sure that this server is always telling you the truth, and not, for example, manufacturing chat messages or social media posts made by a person, messages are signed using a clients' public identity key.</p> <pre><code>flowchart LR\n    hs[(Your Home Server)] --- you(You)\n    you -- Send signed message --&gt; fs[(A Foreign Server)]\n    fs -- Forwards message --&gt; other(Other User)\n    fs --&gt; verify{Verify message signature}\n    other --&gt; verify\n    verify -- Get certificate from home server to verify --&gt; hs</code></pre> <p>This is how it works:</p> <ul> <li>As touched on previously, every user client has an own identity key pair, comprised of a public and   a private key. The public key is cryptographically linked to the private key, meaning that this public   key can not belong to another private key. Signing data is done using the private key, which ONLY the   client knows. Everyone can then use your public key to prove that this signature was generated by   your client, and that the signature matches the data which was signed.</li> <li>Signatures are unique to a piece of data, meaning that two differing pieces of data signed by the same   or different private keys will always<sup>1</sup> produce different signatures. This is the case, even if the   data only differs minutely (be it by a single space, or a single comma).</li> <li>Your home server attests to a clients' key pair, by creating a certificate for your public key, which   it signs with its own secret, public/private key pair, and then sends to you. Your private key is never   sent anywhere at all, and it does not need to be.</li> </ul> <p>Now, your public identity key and your home servers' identity key are 'linked' to each other. This is represented in the ID-Cert you then receive from your home server.</p> <ul> <li>When communicating with another \"foreign\" server in polyproto, you first send that server your ID-Cert.   The server can then prove the validity of your identity, simply by asking your home server for its public   key and performing a quick signature verification. </li> <li>When sending data to the server, such as chat messages, your client computes the signature for that   message using your private key, and attaches this signature to the message you send to other servers. </li> <li>Any user, at any point, can now take this signature, your identity certificate and your home servers'   public key and cryptographically verify that it was, in fact, you who sent the message, and that the   message was not tampered with in any way. To distribute the load of ID-Cert requests more evenly, it   is always the duty of the server that the data exchange is happening on, to cache and hand out ID-Certs   of users.</li> </ul> <p>Info</p> <p>If you are interested about the details, feel free to jump to  section 7.1 in the protocol in the specification document, which covers this exact thing and more.</p>"},{"location":"Overviews/core/#trust","title":"Trust","text":"<p>Trusting the smallest possible amount of entities is great practice when it comes to security. polyproto makes sure that almost everyone you do trust is under constant scrutiny, and thus provides measures to verify a data authors' identity, and that the actual data has not been tampered with.</p> <p>Aside from yourself, the entity with the most trust assigned to it is your home server. Creating your identity on a specific home server is a pledge from that server and its admins to you, where they promise not to create sessions on your behalf, or to otherwise perform actions which can be publicly identified to be carried out by you, without your explicit consent.</p> <p>Should you ever change your mind about your home server's trustworthiness, you can always migrate to another server while keeping the ownership status of your data on all servers you have sent data to, even if your home server is offline indefinitely.</p>"},{"location":"Overviews/core/#multi-use","title":"Multi-use","text":"<p>polyprotos' API definitions and specification document intentionally leave space for implementation-specific data to be sent, where it makes sense. Nothing about the core protocol makes polyproto inherently unsuitable for any purpose.</p>"},{"location":"Overviews/core/#federation","title":"Federation","text":"<p>Federation in polyproto means using one identity or client to interact with multiple servers or even services at once. Implementing federation is straightforward, and entirely seamless to use for end users.</p>"},{"location":"Overviews/core/#technology","title":"Technology","text":"<p>Probably the most refreshing aspect about this new protocol is, that it is really boring. There is really nothing new about any given atomic aspect of polyproto. Polyproto uses well-known, tried and battle-tested technologies, such as asymmetric encryption, X.509-based public key infrastructure and -certificates, digital signatures, JSON over REST and other, already well established technologies such as WebSockets.</p> <p>polyproto should be effortless - both for developers and for end users, who, ideally, should never have to notice any of the technical stuff going on in the background.</p>"},{"location":"Overviews/core/#conclusion","title":"Conclusion","text":"<p>This is just an outline about how polyproto works. The goal with this outline is to inform about the most relevant parts, while intentionally leaving out some details for the sake of clarity. If you have read and understood this overview, you should have no - or at least way less - trouble reading the full protocol specification, which covers a lot more details!</p> <ol> <li> <p>Signature/hash collisions, which although theoretically possible, are extraordinarily infrequent and thus, negligible in practical scenarios.\u00a0\u21a9</p> </li> </ol>"},{"location":"Protocol%20Specifications/chat/","title":"polyproto-chat Specification","text":"<p>TODO</p> <p>TODO: This is a work in progress. Chat-related content is currently being migrated over from the polyproto-core specification.</p>"},{"location":"Protocol%20Specifications/chat/#4-federating-directgroup-messages","title":"4. Federating direct/group messages","text":""},{"location":"Protocol%20Specifications/chat/#41-direct-messages","title":"4.1 Direct messages","text":"<p>Federating direct messages is straightforward. When Alice sends a message to Bob, their client will send the message to Bob's home server via an API request. Bob's home server will then send the message to Bob's client via an established WebSocket connection, and vice versa.</p>"},{"location":"Protocol%20Specifications/chat/#42-group-messages","title":"4.2 Group messages","text":"<p>Group messages work just like guilds, in the sense that data is stored by the home server of the group's creator, meaning that all group members will have to communicate with the group creator's home server. If the group creator leaves the group, the ownership of the group is transferred to another member. The group chat stays on the group creator's home server.</p>"},{"location":"Protocol%20Specifications/chat/#6-encrypted-channels-and-groups","title":"6. Encrypted channels and groups","text":"<p>Note, that in the below sequence diagrams, the MLS Welcome message and the MLS Group notify message are all encrypted using the identity key of the recipient.</p>"},{"location":"Protocol%20Specifications/chat/#61-encrypted-guild-channels","title":"6.1 Encrypted guild channels","text":"<p>Encrypting a guild channel is done by a client with the <code>MANAGE_CHANNEL</code> permission. Upon successfully requesting enabling encryption of a channel, all future messages in it will be encrypted. Joining an encrypted channel is done by sending a join request to the server. The server will then notify the channels' members of the join request. The members will then decide whether to accept or reject the join request. If the join request is accepted by any member, that member will initiate the MLS welcoming process. If the member finds that the join request is invalid (perhaps due to an invalid <code>KeyPackage</code>), the join request must be denied. It is imperative that join requests are verified correctly by the server.</p> <p> Text Only<pre><code>     Charlie                                        Server                                            Alice                         Bob\n     |                                              |                                                 |                             |\n     | Channel join request + KeyPackage            |                                                 |                             |\n     |---------------------------------------------&gt;|                                                 |                             |\n     |                                              |                                                 |                             |\n     |                                              | Notify group of join request                    |                             |\n     |                                              |-----------------------------------              |                             |\n     |                                              |                                  |              |                             |\n     |                                              |&lt;----------------------------------              |                             |\n     |                                              |                                                 |                             |\n     |                                              | Channel join request + Charlie's KeyPackage     |                             |\n     |                                              |------------------------------------------------&gt;|                             |\n     |                                              |                                                 |                             |\n     |                                              |                                                 | Verify Charlie's KeyPackage |\n     |                                              |                                                 |------------------------     |\n     |                                              |                                                 |                       |     |\n     |                                              |                                                 |&lt;-----------------------     |\n     |                                              |                                                 |                             |\n     |                                              |             Notify group of new member: Charlie |                             |\n     |                                              |&lt;------------------------------------------------|                             |\n     |                                              |                                                 |                             |\n     |                                              |                           Encrypted MLS Welcome |                             |\n     |                                              |&lt;------------------------------------------------|                             |\n     |                                              |                                                 |                             |\n     |                                              | Forward: Notify group of new member: Charlie    |                             |\n     |                                              |------------------------------------------------------------------------------&gt;|\n     |                                              |                                                 |                             |\n     | Forward: Notify group of new member: Charlie |                                                 |                             |\n     |&lt;---------------------------------------------|                                                 |                             |\n     |                                              |                                                 |                             |\n     |               Forward: encrypted MLS Welcome |                                                 |                             |\n     |&lt;---------------------------------------------|                                                 |                             |\n     |                                              |                                                 |                             |\n</code></pre> Fig. 3: Sequence diagram of a successful encrypted channel join in which Alice acts as a gatekeeper. The sequence diagram assumes that Alice can verify Charlies' public key to indeed belong to Charlie, and that Alice accepts the join request.</p>"},{"location":"Protocol%20Specifications/chat/#62-encrypted-direct-messages","title":"6.2 Encrypted direct messages","text":"<p>Adding another person to a direct message is not possible, and would not make much sense, as the new person cannot see any messages that were sent before they joined the group. If Alice wants to add Charlie to a direct message with Bob, she will have to create a new direct message with Bob and Charlie.</p> <p>Text Only<pre><code>Alice                                          Server                             Bob\n|                                              |                                  |\n| Request Bob's KeyPackages                    |                                  |\n|---------------------------------------------&gt;|                                  |\n|                                              |                                  |\n|                            Bob's KeyPackages |                                  |\n|&lt;---------------------------------------------|                                  |\n|                                              |                                  |\n| Verify Bob's KeyPackages                     |                                  |\n| -----------------------                      |                                  |\n|                       |                      |                                  |\n|&lt;-----------------------                      |                                  |\n|                                              |                                  |\n| Notify group of new member: Bob              |                                  |\n|---------------------------------------------&gt;|                                  |\n|                                              |                                  |\n| Encrypted MLS Welcome                        |                                  |\n|---------------------------------------------&gt;|                                  |\n|                                              |                                  |\n|                                              | Forward: New group member: Bob   |\n|                                              |---------------------------------&gt;|\n|                                              |                                  |\n|                                              | Forward encrypted MLS Welcome    |\n|                                              |---------------------------------&gt;|\n|                                              |                                  |\n</code></pre> Fig. 4: Sequence diagram of a successful encrypted direct message creation. </p>"},{"location":"Protocol%20Specifications/chat/#63-encrypted-group-messages","title":"6.3 Encrypted group messages","text":"<p>Encrypted group messages work by using the traditional MLS protocol, with the additional concept of group owners. Only group owners can add new members to the group and forcibly remove others from the group. The Group owner is determined by the Client-Server API.</p> <p>Text Only<pre><code>Alice (gatekeeper)                                 Server                                  Bob       Charlie\n|                                                  |                                       |         |\n| Request Bob's KeyPackages                        |                                       |         |\n|-------------------------------------------------&gt;|                                       |         |\n|                                                  |                                       |         |\n|                                Bob's KeyPackages |                                       |         |\n|&lt;-------------------------------------------------|                                       |         |\n|                                                  |                                       |         |\n| Verify Bob's KeyPackages                         |                                       |         |\n|------------------------                          |                                       |         |\n|                       |                          |                                       |         |\n|&lt;-----------------------                          |                                       |         |\n|                                                  |                                       |         |\n| Notify group of new member: Bob                  |                                       |         |\n|-------------------------------------------------&gt;|                                       |         |\n|                                                  |                                       |         |\n| Encrypted MLS Welcome                            |                                       |         |\n|-------------------------------------------------&gt;|                                       |         |\n|                                                  |                                       |         |\n|                                                  | Forward: New group member: Bob        |         |\n|                                                  |--------------------------------------&gt;|         |\n|                                                  |                                       |         |\n|                                                  | Forward encrypted MLS Welcome         |         |\n|                                                  |--------------------------------------&gt;|         |\n|                                                  |                                       |         |\n| Request Charlie's KeyPackages                    |                                       |         |\n|-------------------------------------------------&gt;|                                       |         |\n|                                                  |                                       |         |\n|                            Charlie's KeyPackages |                                       |         |\n|&lt;-------------------------------------------------|                                       |         |\n|                                                  |                                       |         |\n| Verify Charlie's KeyPackages                     |                                       |         |\n|----------------------------                      |                                       |         |\n|                           |                      |                                       |         |\n|&lt;---------------------------                      |                                       |         |\n|                                                  |                                       |         |\n| Notify group of new member: Charlie              |                                       |         |\n|-------------------------------------------------&gt;|                                       |         |\n|                                                  |                                       |         |\n| Encrypted MLS Welcome                            |                                       |         |\n|-------------------------------------------------&gt;|                                       |         |\n|                                                  |                                       |         |\n|                                                  | Forward: New group member: Charlie    |         |\n|                                                  |--------------------------------------&gt;|         |\n|                                                  |                                       |         |\n|                                                  | Forward: New group member: Charlie    |         |\n|                                                  |------------------------------------------------&gt;|\n|                                                  |                                       |         |\n|                                                  | Forward encrypted MLS Welcome         |         |\n|                                                  |------------------------------------------------&gt;|\n|                                                  |                                       |         |\n</code></pre> Fig. 5: Sequence diagram of a successful encrypted group creation with 3 members.</p>"},{"location":"Protocol%20Specifications/chat/#64-joining-new-devices-from-existing-users","title":"6.4 Joining new devices from existing users","text":"<p>Regardless of channel or group permissions, a user join request from a new device should be accepted by default.</p>"},{"location":"Protocol%20Specifications/chat/#65-best-practices","title":"6.5 Best practices","text":"<ul> <li>In case of encrypted guild channel join requests, it may be a good idea to treat multiple join requests from the same user with different clients as a single join request, when it comes to UI/UX.</li> <li>Joining an encrypted channel, even from an already established member with a new device, should be an event distinctly visible to all members of the channel. This is to prevent a malicious user from joining a channel without the other members noticing.</li> </ul>"},{"location":"Protocol%20Specifications/chat/#glossary","title":"Glossary","text":"<ul> <li>Actor - An entity represented by a federation ID, registered on a home server. Actors can be users, bots, or any other entity with an identity.</li> <li>Client - Any application used by an actor to connect to a server.</li> <li>Federation ID - A unique identifier; In public contexts, usually <code>username@optionalsubdomain.domain.tld</code></li> <li>Foreign client - Any client authenticated on a server that is not its home server.</li> <li>Foreign server - A server that an actor is not registered on; essentially a third party.</li> <li>Home client - Any client registered and authenticated on its home server.</li> <li>Home server - The server that an actor is registered on. Any polyproto-core compliant server hosted on the same domain is also considered a home server.</li> <li>Identity - A unique Federation ID.</li> <li>Identity Key - A key pair representing an actor's identity in a session, used for signing and encrypting messages.</li> <li>Instance - A server hosting polyproto compliant software for clients.</li> <li>polyproto-chat - The chat-API used by Polyphony. An extension of the polyproto protocol, defining the routes and capabilities of the chat-API used by Polyphony.</li> <li>polyproto - The core federation protocol and APIs of polyproto, enabling identification and authorization on 'foreign' servers. It is independent of the chat-API used.</li> <li>Root Certificate - A certificate used to sign other certificates, establishing a chain of trust. In polyproto, only home servers have root certificates.</li> <li>Session - A specific period of interaction between a client and a server, typically identified and authenticated by the use of an identity key. The session begins when the client connects to the server and ends when the client disconnects. During a session, the client can interact with the server (e.g., send messages, make requests) under the identity associated with the session.</li> </ul> <p>The below creation- and update-times are not accurate. This is only an issue on this page. Please have a look at the commit history to view when this document was last updated.</p>"},{"location":"Protocol%20Specifications/core/","title":"polyproto Specification","text":"<p>v0.0.0 - Treat this as an unfinished draft. Semantic versioning v2.0.0 is used to version this specification. The version number specified here also applies to the API documentation.</p> <ul> <li>polyproto Specification</li> <li>1. Terminology used in this document</li> <li>2. Trust model</li> <li>3. APIs and communication protocols<ul> <li>3.3 WebSockets</li> <li>3.3.1 Events over REST</li> </ul> </li> <li>4. Federated identity<ul> <li>4.1 Authentication</li> <li>4.1.1 Registering a new actor on a polyproto home server</li> <li>4.1.2 Authenticating a new client on a polyproto home server</li> <li>4.1.3 Authenticating on a foreign server</li> <li>4.2 Challenge Strings</li> <li>4.3 Abuse prevention</li> </ul> </li> <li>5. Users</li> <li>6. Encryption<ul> <li>6.1. KeyPackages</li> <li>6.1.1 Last resort KeyPackages</li> <li>6.2 Initial authentication</li> <li>6.3 Multi-device support</li> </ul> </li> <li>7. Keys and signatures<ul> <li>7.1 Home server signed certificates for public client identity keys (ID-Cert)</li> <li>7.1.1 Structure of an ID-Cert<ul> <li>7.1.1.1 Distinguished Names (<code>DNs</code>)</li> <li>7.1.1.2 Extensions and constraints</li> </ul> </li> <li>7.1.2 Necessity of ID-Certs</li> <li>7.1.3 Key rotation<ul> <li>7.1.3.1 A note about CRLs (Certificate revocation lists)</li> </ul> </li> <li>7.2 Actor identity keys and message signing</li> <li>7.2.2 Message verification</li> <li>7.3 Best practices</li> <li>7.3.1 Signing keys and ID-Certs</li> <li>7.3.2 Home server operation and design</li> </ul> </li> <li>8. Account migration<ul> <li>8.1 Reassigning ownership</li> <li>8.1.1 Migrating an actor</li> <li>8.1.2 Re-signing data</li> <li>8.2 Moving data</li> </ul> </li> </ul> <p>The polyproto protocol is a home-server-based identity federation protocol specification intended for use in applications where actor identity is needed. polyproto focuses on federated identity, and apart from the usage of Messaging Layer Security (MLS) for encryption, does not specify any application-specific features. Instead, it is intended to be used as a base for application implementations and other protocols, such as <code>polyproto-chat</code> - a chat protocol built on top of polyproto. Through a shared \"base layer\", polyproto implementations are intercompatible in a way where one identity can be used across various polyproto implementations.</p> <p>No part of polyproto is considered less important than any other part, and all parts of polyproto are required for a polyproto implementation to be considered compliant with the polyproto specification. The only exception to this is the encryption part of polyproto, which is optional, as the necessity of encryption depends on the specific implementation.</p> <p>This document is intended to be used as a starting point for developers wanting to develop software, which can operate with other polyproto implementations.</p>"},{"location":"Protocol%20Specifications/core/#1-terminology-used-in-this-document","title":"1. Terminology used in this document","text":"<p>In addition to the terminology found in the glossary located at the end of this document, the following terminology is used throughout this document:</p> <ul> <li>Message, Messages: In the context of this protocol specification, a message is any piece of data sent by a client that is intended to be identifiable as being sent by a specific actor. To qualify as a \"message\", this piece of data must also, at any point in time, and also if only briefly, be visible to other users or to the unauthenticated public. Examples of things that would qualify as messages include:<ul> <li>A message sent to another actor in a chat application</li> <li>A post on a social media platform</li> <li>A \"like\" interaction on a social media platform</li> <li>Reaction emojis in Discord-like chat applications</li> <li>Group join or leave messages</li> <li>Reporting a post or actor, if the report is not anonymous</li> </ul> </li> </ul> <p>Terminology not specified in this section or in the glossary has been defined somewhere else in this document.</p>"},{"location":"Protocol%20Specifications/core/#2-trust-model","title":"2. Trust model","text":"<p>polyproto operates under the following trust assumptions:</p> <ol> <li>Users entrust their home server and its admins with data security and discretion on actions appearing as actor-performed.</li> <li>Users only distrust their home servers in case of irregularities or conflicting information.</li> <li>In a federated context, users trust foreign servers with all unencrypted data.</li> <li>Users trust MLS channel members with their data and attached metadata.</li> <li>Foreign servers cannot impersonate users without explicit consent.</li> <li>Users rely on their home servers for identity key certification, without the home servers possessing the identity.</li> </ol>"},{"location":"Protocol%20Specifications/core/#3-apis-and-communication-protocols","title":"3. APIs and communication protocols","text":"<p>The polyproto specification defines a set of APIs. In addition to these REST APIs, polyproto employs WebSockets for real-time communication between clients and servers.</p>"},{"location":"Protocol%20Specifications/core/#33-websockets","title":"3.3 WebSockets","text":"<p>WebSockets enable real-time communication between actor clients and servers.</p> <p>WebSocket connections to polyproto servers consist of the following cycle:</p> <pre><code>sequenceDiagram\nautonumber\n\nactor c as Client\nparticipant g as Gateway\n\nc-&gt;&gt;g: Establish connection\ng-&gt;&gt;c: Recieve hello event\n\nloop TODO: interval\n  c-&gt;&gt;g: Send heartbeat event\n  g-&gt;&gt;c: Send heartbeat ACK Event\nend\n\nc-&gt;&gt;g: Send identify payload\n\nalt Server accepts\n  g-&gt;&gt;c: Send ready event\nelse Server defined reason\n  g-&gt;&gt;c: Disconnect with specified reason\nend\n\n\nopt Resume connection#59;&lt;br /&gt;otherwise, repeat from step 1\n  c-&gt;&gt;g: Open new connection\n  c-&gt;&gt;g: Send resume event\n  g-&gt;&gt;c: Send missed events\n  g-&gt;&gt;c: Send resumed event\nend\n</code></pre> <p>Fig. 1: Sequence diagram of a WebSocket connection to a polyproto server.</p> <p>Info</p> <p>To learn more about polyproto WebSockets and WebSocket Events, consult the WebSockets documentation.</p>"},{"location":"Protocol%20Specifications/core/#331-events-over-rest","title":"3.3.1 Events over REST","text":"<p>For some implementation contexts, a constant WebSocket connection might not be wanted. A client can instead opt to query an API endpoint to receive events, which would normally be sent through the WebSocket connection. Concrete polyproto-implementations and extensions can decide whether this alternative behaviour is supported. </p> <p>Example</p> <p>An example of an implementation context where having a constant WebSocket might not be wanted would be Urban IoT devices, or devices with a limited or only periodically available internet connection. </p> <p>Querying this endpoint yields a JSON-Array containing either all events the session has missed since disconnecting from the WebSocket, or all events the session has missed since last querying the endpoint.</p> <p>Depending on how many events the session has missed, the earliest events might be excluded from the response to limit the response bodies size. This behaviour should be explicitly documented in implementations or extensions of polyproto.</p> <p>Due to the intended use cases for retrieving events through REST rather than WebSockets, this endpoint is not a long-polling endpoint.</p> <p>There are three intended, main modes for retrieving events in polyproto</p> <ol> <li>Keep a constant WebSocket connection whenever possible</li> <li>Keep a semi-constant WebSocket connection, perhaps connecting every x minutes for a set period of    time</li> <li>Do not use WebSockets and only query the REST API</li> </ol> <p>Polling a REST endpoint is inherently inefficient and therefore should only be done with a high interval, ranging from a few minutes to a few days. If a client requires information more often than that, then a WebSocket connection should be considered.</p>"},{"location":"Protocol%20Specifications/core/#4-federated-identity","title":"4. Federated identity","text":"<p>The federation of actor identities allows users to engage with foreign servers as if they were their home servers. For instance, in polyproto-chat, an actor can send direct messages to users from a different server or join the Guilds of other servers.</p> <p>Identity certificates defined in sections #7. Keys and signatures and #7.1 Home server signed certificates for public client identity keys (ID-Cert) are employed to sign messages that the actor sends to other servers.</p> <p>Using one identity for several polyproto implementations</p> <p>An actor can choose to use the same identity for multiple polyproto implementations. If section 4.1.3 is implemented correctly, this should not be a problem.</p> <p>Info</p> <p>You can read more about the Identity Pubkey and Certificate in 7. Keys and signatures.</p>"},{"location":"Protocol%20Specifications/core/#41-authentication","title":"4.1 Authentication","text":""},{"location":"Protocol%20Specifications/core/#411-registering-a-new-actor-on-a-polyproto-home-server","title":"4.1.1 Registering a new actor on a polyproto home server","text":"<p>Registering a new actor in the context of polyproto is done through an API route defined in the polyproto \"No registration needed\" API documentation.</p> <p>To register, the client sends the necessary information to their home server. The server verifies the data, checks username availability, and responds with HTTP 201 and the new identity's federation ID, if successful. However, a session token is not provided until the actor authenticates a client, as detailed in section 4.1.2.</p> <p><pre><code>sequenceDiagram\nautonumber\n\nactor c as Client\nparticipant s as Server\n\nc-&gt;&gt;s: Registration information\ns-&gt;&gt;s: Verify correctness of provided information,&lt;br /&gt;check if username is available, etc\n\nalt verification successful\n  s-&gt;&gt;s: Verify provided CSR\n\n  alt CSR okay\n    s-&gt;&gt;s: Sign CSR\n    s-&gt;&gt;c: HTTP status code 201, with actor federation ID\n  end\nend</code></pre> Fig. 2: Sequence diagram of a successful identity creation process.</p>"},{"location":"Protocol%20Specifications/core/#412-authenticating-a-new-client-on-a-polyproto-home-server","title":"4.1.2 Authenticating a new client on a polyproto home server","text":"<p>To access their account from a new device, an actor authenticates the session with their home server by sending authentication information and a certificate signing request (CSR) for the new client. If verified successfully, the server signs the CSR and responds with the newly generated ID-Cert and a session token corresponding to this ID-Cert.</p> <p><pre><code>sequenceDiagram\nautonumber\n\nactor c as Client\nparticipant s as Server\n\nc-&gt;&gt;s: Auth information, CSR\ns-&gt;&gt;s: Verify correctness of provided auth information\n\nalt Verified successfully\n  s-&gt;&gt;s: Verify provided CSR\n  alt CSR okay\n  s-&gt;&gt;s: Sign CSR\n  s-&gt;&gt;c: HTTP status code 201, ID-Cert + session token\n  end\nend\n</code></pre> Fig. 3: Sequence diagram of a successful client authentication process.</p> <p>The client is now authenticated and can use the session token and ID-Cert to perform actions on behalf of the actor identified by the ID-Cert.</p>"},{"location":"Protocol%20Specifications/core/#413-authenticating-on-a-foreign-server","title":"4.1.3 Authenticating on a foreign server","text":"<p>Authenticating on a foreign server requires the actor to sign a challenge string with their private identity key and send it, along with their ID-Cert, to the server. The server then validates the ID-Cert's origin, the challenge string's signature, and the ID-Cert's validity.</p> <p>If the verification is successful, the foreign server can issue a session token to the actor.</p> <p>Example: Say that Alice is on server A, and wants to authenticate on Server B, using her existing identity.</p> <p>Alice's client sends a request to Server B for a challenge string, telling Server B the session ID they are communicating from in the process. Upon receiving a response, Alice signs this challenge string with the correct private key. They then send the signature to Server B. Server B can now verify that it was actually Alice who signed the string, and not a malicious outsider. Server B does this by requesting Alice's ID-Cert, specifically the ID-Cert matching the session ID Alice identified with to Server B. If all goes well, server B will send a newly generated session token back to Alice's client. Alice's client can then authenticate with server B by using this token.</p> <p><pre><code>sequenceDiagram\nautonumber\n\nactor a as Alice\nparticipant sb as Server B\nparticipant sa as Server A\n\na-&gt;&gt;sb: Challenge string request including current Session ID\nsb-&gt;&gt;a: Challenge string\na-&gt;&gt;sb: Signed challenge, ID-Cert, optional payload\nsb-&gt;&gt;sa: Get Server A Public Certificate\nsa-&gt;&gt;sb: Send Public Certificate\nsb-&gt;&gt;sb: Verify signature of challenge string\nsb-&gt;&gt;a: Session token, optional payload</code></pre> Fig. 4: Sequence diagram of a successful identity verification.</p> <p>In the diagram, Alice's \"optional payload\" is extra data that might be requested by servers. This is useful when using a single identity across various polyproto implementations, due to differing information needs. The payload is signed with the actor's private identity key.</p> <p>Likewise, the \"optional payload\" sent by the server in the above diagram can be used by implementations to send additional information to the client. An example might be initial account information.</p> <p>Example</p> <p>Alice currently has a polyproto identity, which she created when signing up for \"https://example.com/chat\". When signing up for this service, she didn't need to provide any additional information on registration. However, when she wants to actor her existing identity to sign up for \"https://example.com/social\", she is asked to provide her email address, which she can provide as the \"optional payload\". The server can then store the email address in its' database, associate it with Alice's identity, and let Alice log in with her existing identity. </p> <p>If Alice's session token expires, they can repeat this process of requesting a challenge string and, together with her ID-Cert, exchange it for a session token. However, if Alice wants to access this third party account from a completely new device, they will have to perform the steps described in section 4.1.2 to obtain a valid ID-Cert for that session.</p>"},{"location":"Protocol%20Specifications/core/#42-challenge-strings","title":"4.2 Challenge Strings","text":"<p>Servers generate alphanumeric challenge strings to verify an actor's private identity key possession. These strings, ranging from 32 to 256 characters, have a UNIX timestamp lifetime. If the current timestamp surpasses this lifetime, the challenge fails. The actor signs the string, sending the signature and their ID-Cert to the server, enabling identity confirmation.</p> <p>Challenge strings counteract replay attacks. Their uniqueness ensures that even identical requests have different signatures, preventing malicious servers from successfully replaying requests.</p>"},{"location":"Protocol%20Specifications/core/#43-abuse-prevention","title":"4.3 Abuse prevention","text":"<p>To protect users from malicious home servers secretly acting on the behalf of non-consenting users, a mechanism is needed to prevent home servers from generating federation tokens for users without their consent.</p> <p>Potential abuse scenario</p> <p>A malicious home server can potentially request a federation token on behalf of one of its users, and use it to generate a session token on the actor's behalf. This is a problem, as the malicious server can then impersonate the actor on another server, as well as read unencrypted data (such as messages, in the context of a chat application) sent on the other server.</p> <p>Abstract</p> <p>The above scenario is not unique to polyproto, and rather a problem other federated services/ protocols, like ActivityPub, have as well. There is no real solution to this problem, but it can be mitigated a bit by making it more difficult for malicious home servers to do something like this without the actor noticing.</p> <p>Polyproto servers need to inform users of new session tokens. This visibility hampers malicious home servers, but does not solve the issue of them being able to create federation tokens for servers the actor does not connect to. This is because, naturally, users cannot receive notifications without a connection. Clients re-establishing server connections must be updated on any new session tokens generated during their absence. The <code>NEW_SESSION</code> gateway event must be dispatched to all sessions, excluding the new session. The <code>NEW_SESSION</code> event's stored data can be accessed in the Gateway Events documentation.</p> <p>Note</p> <p>With proper safety precautions and strong encryption, it is extremely unlikely for a malicious server to be able to listen in on encrypted conversations, without all users in that  conversation noticing. MLS's forward secrecy guarantees ensure that, in theory, a malicious session cannot decrypt any messages sent before its' join epoch. If secrecy or confidentiality are of concern, users should host their own home server and use end-to-end encryption.</p>"},{"location":"Protocol%20Specifications/core/#5-users","title":"5. Users","text":"<p>Every client requires an associated actor identity. Users are distinguished by a unique federation ID (FID), consist of their username, which is unique per instance, and the instance's root domain. This combination ensures global uniqueness.</p> <p>FIDs used in public contexts are formatted as <code>actor@optionalsubdomain.domain.tld</code>, and are case-insensitive.</p> <p>The following regular expression can be used to validate actor IDs: <code>\\b([A-Z0-9._%+-]+)@([A-Z0-9.-]+\\.[A-Z]{2,})\\b</code>.</p> <p>Note</p> <p>Validating a federation ID with the above regex does not guarantee that the ID is valid. It only indicates that the federation ID is formatted correctly.</p> <p>For all intents and purposes, a federation ID is a display of identity. However, verifying identity claims is crucial. See Section #7.1 and Section #7.2.2 for more information.</p>"},{"location":"Protocol%20Specifications/core/#6-encryption","title":"6. Encryption","text":"<p>About MLS</p> <p>Polyproto offers end-to-end encryption for messages via Message Layer Security (MLS). polyproto compliant servers take on the role of both an Authentication Service and a Delivery Service in the context of MLS.</p> <p>MLS is a cryptographic protocol that provides confidentiality, integrity, and authenticity guarantees for group messaging applications. It builds on top of the Double Ratchet Algorithm and X3DH to provide these security guarantees.</p> <p>Implementations of polyproto can opt to support encryption to secure communication channels. The selected security protocol for all polyproto implementations is the Messaging Layer Security protocol, given its feasibility within the implementation context. MLS inherently supports negotiation of protocol versions, cipher suites, extensions, credential types, and extra proposal types. For two implementations of polyproto to be compatible with each other in the context of encryption, they must have overlapping capabilities in these areas.</p> <p>The following sections explain the additional behavior that polyproto implementations utilizing MLS must implement.</p>"},{"location":"Protocol%20Specifications/core/#61-keypackages","title":"6.1. KeyPackages","text":"<p>Warning</p> <p>The sections 6.1 and 6.1.1 are not exhaustive and do not cover all aspects of MLS and KeyPackages. They exist solely to give a general overview of how KeyPackages are used in polyproto. Please read and understand the MLS specification (RFC9420) to implement polyproto correctly.</p> <p>A polyproto compliant server must store KeyPackages for all clients registered on it. The KeyPackage is a JSON object that contains the following information:</p> JSON<pre><code>{\n  \"protocol_version\": \"&lt;Version&gt;\",\n  \"cipher_suite\": \"&lt;CipherSuite&gt;\",\n  \"init_key\": \"&lt;HPKEPublicKey&gt;\",\n  \"leaf_node\": \"&lt;LeafNode&gt;\",\n  \"extensions\": \"&lt;Extensions&gt;\",\n}\n</code></pre> <ul> <li><code>protocol_version</code> denotes the MLS protocol version.</li> <li><code>cipher_suite</code> indicates the used cipher suite for this KeyPackage. Note that a server can store many KeyPackages for a single actor, to support various cipher suites.</li> <li><code>init_key</code> is a public key for encrypting initial group secrets.</li> <li><code>leaf_node</code> is a signed <code>LeafNodeTBS</code> struct as defined in section <code>7.2. Leaf Node Contents</code> in RFC9420. A <code>LeafNode</code> has information representing a users' identity, in the form of the users' ID-Cert for a given session or client. The <code>LeafNodeTBS</code> is signed by using the actor's private identity key.</li> <li><code>extensions</code> can be used to add additional information to the protocol, as defined in section <code>13. Extensibility</code> in RFC9420.</li> </ul> <p>A KeyPackage is supposed to be used only once. Servers must ensure the following things: -  That any KeyPackage is not given out to clients more than once. -  That the <code>init_key</code> values of all KeyPackages are unique, as the <code>init_key</code> is what makes the KeyPackage one-time use. -  That the contents of the <code>LeafNode</code> and the <code>init_key</code> were signed by the actor who submitted the KeyPackage.</p> <p>Because KeyPackages are supposed to be used only once, servers should retain multiple valid KeyPackages for each actor, alerting clients when their stock is running low. Consult the \"Registration needed\"-API for more information about how servers should request new KeyPackages from clients. Servers should delete KeyPackages when their validity lapses.</p> <p>Servers only store KeyPackages for home server users, not for foreign users.</p> <p>About keys</p> <p>It is recommended that keys are generated using the <code>EdDSA</code> signature scheme, however, other signature schemes may be used as well. Consider, that intercompatibility can only be guaranteed if all communicating parties have an overlapping set of supported signature schemes.</p>"},{"location":"Protocol%20Specifications/core/#611-last-resort-keypackages","title":"6.1.1 Last resort KeyPackages","text":"<p>A \"last resort\" KeyPackage, which, contrasting regular KeyPackages, is reusable, is issued when a server runs out of regular KeyPackages for an actor. This is to prevent <code>DoS</code> attacks, where malicious clients deplete all KeyPackages for a given actor, blocking that actor's inclusion into encrypted groups or guild channels.</p> <p>Servers are to replace a \"last resort\" KeyPackage after it has been used at least once by requesting one from the client.</p>"},{"location":"Protocol%20Specifications/core/#62-initial-authentication","title":"6.2 Initial authentication","text":"<p>During the initial authentication process, a client must provide at least one KeyPackage and one \"last resort\" KeyPackage to the server, in addition to the required registration information.</p> <p>The public identity key inside the <code>LeafNode</code> of this KeyPackage corresponds to the public identity key found inside a clients' ID-Cert.</p>"},{"location":"Protocol%20Specifications/core/#63-multi-device-support","title":"6.3 Multi-device support","text":"<p>polyproto servers and clients employing encryption must support multi-device use. The MLS protocol assigns each device a unique <code>LeafNode</code> and prohibits key sharing across devices. Each device offers distinct KeyPackages and an own ID-Cert.</p>"},{"location":"Protocol%20Specifications/core/#7-keys-and-signatures","title":"7. Keys and signatures","text":""},{"location":"Protocol%20Specifications/core/#71-home-server-signed-certificates-for-public-client-identity-keys-id-cert","title":"7.1 Home server signed certificates for public client identity keys (ID-Cert)","text":"<p>The ID-Cert, a X.509 certificate, validates a public actor identity key. It is an actor-generated CSR (Certificate Signing Request), signed by a home server, encompassing actor identity information and the client's public identity key. Clients can get an ID-Cert in return for a valid and well-formed CSR.</p> <p>All ID-Certs are valid X.509 certificates. However, not all X.509 certificates are valid ID-Certs.</p> <p>ID-Certs form the basis of message signing and verification in polyproto. They are used to verify the identity of a client, and to verify the integrity of messages sent by a client.</p> <p>A CSR includes the following information, according to the X.509 standard:</p> <ul> <li>The public identity key of the client.</li> <li>The federation ID of the actor associated with the client.</li> <li>The session ID of the client. The session ID is a unique identifier for a session, which does not change when a client rotates their identity keys.</li> <li>Optionally, an expiry date for the certificate. This expiry date must be less than or equal to the expiry date of the home servers' public identity key certificate.</li> </ul> <p>When signing a CSR, the home server must verify the correctness of all claims presented in the CSR.</p> <p>Important</p> <p>All entities receiving an ID-Cert must inspect the certificate for correctness and validity.  This includes checking the signature, the certificate's validity period, the certificate's issuer and all other claims presented in the certificate.</p> <p>The resulting ID-Cert then holds the following information:</p> Field Description Special requirements, if any X.509 equivalent The home servers' fully qualified domain name. Distinguished Name Issuer Name The federation ID of the actor. Distinguished Name, Must be unique across all actors on the home server. Subject Name A unique identifier for the certificate. Must be unique across all certificates issued by a home server. Serial Number The algorithm used to sign the certificate. Certificate Signature Algorithm &amp; Signature Algorithm ID The signature of the certificate, generated by using the home servers' private identity key. Certificate Signature The expiry date of the certificate. Time must not be after expiry date of the home server's root certificate Validity period: Not After Certificate validity period starting date Time must not be before the home server's root certificate was generated Validity period: Not Before X.509 Version Number (v3) v3 Version Number The public identity key of the client. Subject Public Key Info: Subject Public Key The public key algorithm used to generate the client's public identity key. Subject Public Key Info: Public Key Algorithm The session ID of the client. No two valid certificates for one session ID can exist. Session IDs have to be unique per user. Subject Unique Identifier Extensions Extensions"},{"location":"Protocol%20Specifications/core/#711-structure-of-an-id-cert","title":"7.1.1 Structure of an ID-Cert","text":"<p>The ID-Cert is a valid X.509 certificate, and as such, it has a specific structure. The structure of an X.509 certificate is defined in RFC5280. ID-Certs encompass a subset of the structure of an X.509 certificate.</p>"},{"location":"Protocol%20Specifications/core/#7111-distinguished-names-dns","title":"7.1.1.1 Distinguished Names (<code>DNs</code>)","text":"<p>The Distinguished Names (<code>DNs</code>), according to the LDAP Data Interchange Format (LDIF). The <code>DN</code> is a sequence of relative distinguished names (<code>RDNs</code>).</p> <p>The distinguished name must be unique for each certificate issued by a home server. The <code>DN</code> of an ID-Cert must include the following fields:</p> Text Only<pre><code>dn: cn=&lt;actor or home server name&gt;, dc=&lt;home server subdomain, if any&gt;, dc=&lt;home server domain&gt;, dc=&lt;home server tld&gt;\n</code></pre> <p>If the home server does not have a subdomain, the <code>dc</code> field for the subdomain should be omitted.</p> <p>Optionally, the <code>DN</code> can include an <code>ou</code> field, representing the organizational unit of the actor.</p>"},{"location":"Protocol%20Specifications/core/#7112-extensions-and-constraints","title":"7.1.1.2 Extensions and constraints","text":"<p>The following constraints must be met by ID-Certs:</p> <ul> <li>If the ID-Cert is a root certificate</li> <li>It must have the <code>CA</code> flag set to <code>true</code>. The path length constraint must be set to <code>0</code>.</li> <li>It must have the <code>keyCertSign</code> and <code>cRLSign</code> key usage flags set to <code>true</code>.</li> <li>If the ID-Cert is an actor certificate</li> <li>It must have the <code>CA</code> flag set to <code>false</code>.</li> <li>It must have the <code>keyCertSign</code> and <code>cRLSign</code> key usage flags set to <code>false</code>.</li> <li>It must have the <code>digitalSignature</code> key usage flag set to <code>true</code>.</li> </ul>"},{"location":"Protocol%20Specifications/core/#712-necessity-of-id-certs","title":"7.1.2 Necessity of ID-Certs","text":"<p>The addition of a certificate might seem ubiquitous, but it is necessary to prevent a malicious foreign server from abusing public identity key caching to impersonate an actor. Consider the following example which employs foreign server public identity key caching, but no home server issued identity key certificates:</p> <p>Potential abuse scenario</p> <p>A malicious foreign server B can fake a message from Alice (Home server: Server A) to Bob (Home Server: Server B), by generating a new identity key pair and using it to sign the malicious message. The foreign server then sends that message to Bob, who will then request Alice's public identity key from Server B, who will then send Bob the malicious public identity key. Bob will succeed in verifying the signature of the message, and not notice that the message is malicious.</p> <p>The above scenario is not possible with home server issued identity key certificates, as the malicious server cannot generate an identity key pair for Alice, which is signed by Server A.</p>"},{"location":"Protocol%20Specifications/core/#713-key-rotation","title":"7.1.3 Key rotation","text":"<p>A session may choose to rotate their ID-Cert at any time. This is done by generating a new identity key pair, using the new private key to generate a new CSR, and sending the new Certificate Signing Request to the home server, along with at least one new KeyPackage and a corresponding 'last resort' KeyPackage. The home server will then generate the new ID-Cert, send it to the client, and let all associated clients know that this clients' public identity key has changed. The server does this by sending a <code>CLIENT_KEY_CHANGE</code> gateway event to those clients.</p> <p>For example, in the context of a chat application built with polyproto-chat, an associating relationship between two clients exists, if:</p> <ul> <li>the two clients share a guild, a group or a direct message channel</li> <li>they are friends</li> <li>they have a pending friend request between each other.</li> </ul> <p>Rotating keys is done by using an API route which requires authorization. </p> <p>Note</p> <p>Sessions can request a new ID-Cert for any session of the same actor. Most other, currently existing services also allow for this, as it is a common use case for user to want to, perhaps, log out of devices they no longer use. Depending on your use case, this might be a security concern, as it potentially simplifies account takeovers. Whether and how this risk is mitigated is up to  concrete implementations.</p> <p>Before sending any messages to a server, a client that performed a key rotation should inform the server of that change. This is to ensure that the server has cached the correct ID-Cert for this session.</p> <p>Home servers must keep track of the ID-Certs of all users (and their clients) registered on them, and must provide a clients' ID-Cert for a given timestamp on request. This is to ensure messages sent by users, even ones sent a long time ago, can be verified by other servers and their users. This is because the public key of an actor likely changes over time and users must sign all messages they send to servers. Likewise, a client should also keep all of its own ID-Certs stored perpetually, to potentially verify its identity in case of a migration.</p> <p><pre><code>sequenceDiagram\nautonumber\n\nactor c as Client\nparticipant s as Server\n\nc-&gt;&gt;c: Create CSR for own identity key\nc-&gt;&gt;s: Request key rotation/CSR signing, CSR attached\ns-&gt;&gt;s: Verify validity of claims presented in the CSR\nalt verify success\n  s-&gt;&gt;s: Create ID-Cert for Client\n  s-&gt;&gt;c: Respond with ID-Cert\nend\nNote right of s: Send CLIENT_KEY_CHANGE to associated clients</code></pre> Fig. 5: Sequence diagram depicting the process of a client using a CSR to request a new ID-Cert from their home server.</p> <p>A server identity key's lifetime might come to an early or unexpected end, perhaps due to some sort of leak of the corresponding private key. When this happens, the server should generate a new identity key pair and broadcast the <code>SERVER_KEY_CHANGE</code> and <code>LOW_KEY_PACKAGES</code> gateway events to all clients. Clients should regenerate their identity keys, request a new ID-Cert (through a CSR), and respond appropriately to the <code>LOW_KEY_PACKAGES</code> event. Should a client be offline at the time of the key change, it must be informed of the change upon reconnection.</p> <p>Note</p> <p>A <code>LOW_KEY_PACKAGES</code> event is only sent by servers which use MLS encryption. Server/Clients not implementing MLS encryption can safely ignore this event.</p>"},{"location":"Protocol%20Specifications/core/#7131-a-note-about-crls-certificate-revocation-lists","title":"7.1.3.1 A note about CRLs (Certificate revocation lists)","text":"<p>It is common for systems relying on X.509 certificates for user authentication to use Certificate Revocation Lists (CRLs) to keep track of which certificates are no longer valid. This is done to prevent a user from using a certificate that has been revoked.</p> <p>CRLs are difficult to implement well, often requiring many resources to keep up to date, and are also not always reliable. OCSP (Online Certificate Status Protocol) is a more modern, reliable and easier to implement alternative. Still, it potentially requires many resources to keep up with demand, while introducing a more immediate single point of failure.</p> <p>polyproto inherently mitigates some of the possible misuse of a revoked certificate, as the validity of a certificate is usually checked by many parties. Especially, if the revocation process is initiated by the actor themselves, the actor already lets all servers they are connected to know that the certificate in question is no longer valid.</p> <p>polyproto does not require the use of CRLs or OCSP.</p>"},{"location":"Protocol%20Specifications/core/#72-actor-identity-keys-and-message-signing","title":"7.2 Actor identity keys and message signing","text":"<p>As briefly mentioned section #4, users must hold on to an identity key pair at all times. This key pair is used to represent an actor's identity and to verify message integrity, by having an actor sign all messages they send with their private identity key. The key pair is generated by the actor. An actor-generated identity key certificate signing request (CSR) is sent to the actor's home server when first connecting to the server with a new session, or when rotating keys. The key is stored in the client's local storage. Upon receiving a new identity key CSR, a home server will sign this CSR and send the resulting ID-Cert to the client. This certificate is proof that the home server attests to the clients key. Read section 7.1 for more information on the certificate.</p>"},{"location":"Protocol%20Specifications/core/#722-message-verification","title":"7.2.2 Message verification","text":"<p>To ensure message integrity via signing, clients and servers must verify message signatures. This involves cross-checking the message signature against the sender's ID-Cert and the senders' home server's root certificate, while also confirming the validity of the ID-Cert attached to the message and ensuring its public key matches the sender's.</p> <p>Example: Given a signed message from Alice, such as Bob would receive from Server B in Fig. 3, Bob's client would verify the signature of the message like this:</p> <p><pre><code>sequenceDiagram\nautonumber\n\nactor b as Bob\nparticipant sa as Server A\nparticipant sb as Server B\n\nsb-&gt;&gt;b: Alice's signed message\nb-&gt;&gt;sb: Request Alice's ID-Cert\nsb-&gt;&gt;b: Alice's ID-Cert\nb-&gt;&gt;sa: Request Server A ID-Cert\nsa-&gt;&gt;b: Server A ID-Cert\nb-&gt;&gt;b: Verify signature of Alice's message\n</code></pre> Fig. 6: Sequence diagram of a successful message signature verification.</p> <p>Bob's client and Server B should now cache Server A's public identity key and Alice's ID-Cert, to avoid having to request them again.</p> <p>If the verification fails, Bob's client should try to re-request the key from Server B first. Should the verification fail again, Bob's client can try to request Alice's public identity key and ID-Cert from Server A (Alice's home server). The signature verification process should then be re-tried. Should the verification still not succeed, the message should be treated with extreme caution.</p> <p>Why does Bob's client not request Alice's public identity key from Server A?</p> <p>Bob's client could request Alice's public identity key from Server A, instead of Server B. However, this is discouraged, as it</p> <ul> <li>Generates unnecessary load on Server A; Doing it this way distributes the load of public identity key requests more fairly, as the server that the message was sent on is the one that has to process the bulk of public identity key requests.</li> <li>Would expose unnecessary metadata to Server A; Server A does not need to know who exactly Alice is talking to, and when. Only Server B, Alice and Bob need to know this information. Always requesting the public identity key from Server A might expose this information to Server A.</li> </ul> <p>Clients should only use Server A as a fallback for public identity key verification, if Server B does not respond to the request for Alice's public identity key, or if the verification fails with the public identity key from Server B.</p> <p>Info</p> <p>A failed signature verification does not always mean that the message is invalid. It may be that the actor's identity key has changed, and that Server B has not yet received the new public identity key for some reason.</p>"},{"location":"Protocol%20Specifications/core/#73-best-practices","title":"7.3 Best practices","text":""},{"location":"Protocol%20Specifications/core/#731-signing-keys-and-id-certs","title":"7.3.1 Signing keys and ID-Certs","text":"<ul> <li>Actor and client signing keys should be rotated regularly (every 20-60 days). This is to ensure that a compromised key can only be used for a limited amount of time. Server identity keys should be rotated way less often (every 1-5 years), and perhaps only when a leak is suspected.</li> <li>When a server is asked to generate a new ID-Cert for an actor, it must make sure that the CSR is valid and, if set, has an expiry date less than or equal to the expiry date of the server's own ID-Cert.</li> <li>Due to the fact that a <code>SERVER_KEY_CHANGE</code> gateway event is bound to generate a large amount of traffic, servers should only manually generate a new identity key pair when absolutely necessary and instead choose a fitting expiry date interval for their identity key certificates. It might also be a good idea to stagger the sending of <code>SERVER_KEY_CHANGE</code> gateway events, to prevent a server from initiating a DDoS attack on itself.</li> <li>When a client or server receives the information that an actor's client identity key has been changed, the client/server in question should update their cached ID-Cert for the actor in question, taking into account the session ID of the new identity key pair.</li> </ul>"},{"location":"Protocol%20Specifications/core/#732-home-server-operation-and-design","title":"7.3.2 Home server operation and design","text":"<ul> <li>Use a caching layer for your home server to handle the potentially large amount of requests for   ID-Certs without putting unnecessary strain on the database.</li> </ul>"},{"location":"Protocol%20Specifications/core/#8-account-migration","title":"8. Account migration","text":"<p>Account migration allows users to move their account and associated data to another identity. This allows users to switch home servers while not losing ownership of messages sent by them.</p> <p>Migrating an actor always involves reassigning the ownership of all actor-associated data in the distributed network to the new actor. Should the old actor want to additionally move all data from the old home server to another home server, more steps are needed. </p>"},{"location":"Protocol%20Specifications/core/#81-reassigning-ownership","title":"8.1 Reassigning ownership","text":"<p>Migrating an account is done with the following steps:</p> <ol> <li>The actor creates a new account on a new home server.</li> <li>The actor requests the migration from the new home server, specifying the old account's    federation ID.</li> <li>The old actor account confirms the migration request by sending a signed API request to the new home    server. The confirmation contains the federation ID of the new account.</li> <li>The new server sends this information to the old server, which then sends the new server all    information associated with the old account.     The old server now forward requests regarding the old account to the new server.    Alternatively, if the old server is shut down, the new server can request the information    from the old actor directly.</li> <li>The old account can now request the resigning of its messages, transferring ownership of the    messages to the new account. To have all messages from a server re-signed, an actor must    prove that they are the owner of the private keys used to sign the messages.</li> </ol>"},{"location":"Protocol%20Specifications/core/#811-migrating-an-actor","title":"8.1.1 Migrating an actor","text":"<p><pre><code>sequenceDiagram\nautonumber\n\nactor aa as Alice A\nactor ab as Alice B\nparticipant sa as Server A\nparticipant sb as Server B\n\nab-&gt;&gt;sb: Migration request (signed, Alice B-&gt;Server B)\naa-&gt;&gt;sb: Migration request (signed, Alice A-&gt;Server B)\nsb-&gt;&gt;sa: Fetch full profile of Alice A,&lt;br /&gt;attached with migration request\nsa-&gt;&gt;sa: Verify signed migration request\nsa-&gt;&gt;sb: Full profile of Alice A\nsb-&gt;&gt;sb: Verify, replace Alice B with Alice A\nsb-&gt;&gt;ab: New account data\nsa-&gt;&gt;sa: Deactivate Alice A's account\nsa-&gt;&gt;sa: Setup redirect from Alice A to Alice B</code></pre> Fig. 7: Sequence diagram depicting a successful migration of Alice A's account to Alice B's account, where Server A is reachable and cooperative.</p> <p>Alternatively, if Server A is offline or deemed uncooperative, the following sequence diagram depicts how the migration can be done without Server A's cooperation:</p> <p><pre><code>sequenceDiagram\nautonumber\n\nactor aa as Alice A\nactor ab as Alice B\nparticipant sa as Server A\nparticipant sb as Server B\n\nab-&gt;&gt;sb: Migration request (Signed, Alice B-&gt;Server B)\naa-&gt;&gt;sb: Migration request (Signed, Alice A-&gt;Server B)\nsb-&gt;&gt;sa: Fetch full profile of Alice A,&lt;br /&gt;attached with migration request\nsa--xsb: Server A offline send profile or abort?\naa-&gt;&gt;sb: Full profile of Self\nsb-&gt;&gt;sb: Verify, replace Alice B profile with Alice A\nsb-&gt;&gt;ab: New account data\n</code></pre> Fig. 8: Sequence diagram depicting a successful migration of Alice A's account to Alice B's account, where Server A is unreachable or uncooperative.</p> <p>If the old home server is not needed for the migration, why try to contact it in the first place?</p> <p>It is generally preferrable to have the old home server cooperate with the migration, as it allows for a more seamless migration. A cooperative homeserver will be able to provide the new home server with all information associated with the old account. It can also forward requests regarding the old account to the new server, which makes the process more seamless for other users. The \"non-cooperative homeserver migration method\" is only a last resort.</p>"},{"location":"Protocol%20Specifications/core/#812-re-signing-data","title":"8.1.2 Re-signing data","text":"<p>Transferring message ownership from an old to a new account, known as re-signing messages, necessitates coordination between the two accounts, initiated by the old account. To start, the old account sends an API request containing the new account's federation ID to the server where messages should be re-signed. The server responds with all ID-Certs used for signing the old account's messages, along with a challenge string. The old account will then need to prove that it is in possession of the private keys that were used to sign the messages. This is done by signing a challenge string with the private keys. If the server verifies the challenge, it authorizes the new account to re-sign the old account's messages signed with the verified key. Instead of overwriting the message, a new message variant with the new signature is created, preserving the old message.</p> <p>Implementations and protocol extensions should carefully consider the extent of messages that can be re-signed.</p> <p>Example</p> <p>In the case of a social media platform with quote-posting functionality, it is reasonable to assume that re-signing a quoted post is allowed. However, this would likely change the signature of the quoted post, which would be undesirable. Edge cases like these are up to implementations to handle, and should be well documented.</p> <p><pre><code>sequenceDiagram\nautonumber\n\nactor aa as Alice A\nactor ab as Alice B\nparticipant sc as Server C\n\naa-&gt;&gt;sc: Request allow message re-signing for Alice B\nsc-&gt;&gt;aa: List of keys to verify + challenge string\naa-&gt;&gt;sc: Completed challenge for each key on the list\nsc-&gt;&gt;sc: Verify challenge, unlock re-signing for Alice B\nab-&gt;&gt;sc: Request message re-signing for Alice A's messages\nsc-&gt;&gt;ab: List of old messages (including old signatures + certificates)\nab-&gt;&gt;ab: Verify that Server C has not tampered with messages\nab-&gt;&gt;ab: Re-sign messages with own keys\nab-&gt;&gt;sc: Send new messages\nsc-&gt;&gt;sc: Verify that only FID and signature related fields have changed</code></pre> Fig. 9: Sequence diagram depicting the re-signing procedure.</p>"},{"location":"Protocol%20Specifications/core/#82-moving-data","title":"8.2 Moving data","text":"<p>In cases of an imminent server shutdown or distrust in the old server, moving data from the old server is necessary to prevent data loss. This process extends upon the reassigning ownership process, and involves the following steps:</p> <ol> <li>Using the old account, the client requests a data export from your old home server.</li> <li>The old home server sends a data export to the client. The client will check the signatures on    the exported data, to ensure it was not tampered with.</li> <li>The new account re-signs the data with its own keys and imports it into the new home server.</li> <li>The new home server verifies the data and signals that the import was successful.</li> <li>The old client requests the deactivation or deletion of the old account on the old home server.</li> </ol> <pre><code>sequenceDiagram\nautonumber\n\nparticipant sa as Server A\nparticipant sb as Server B\nbox Same Device\nactor aa as Alice A\nactor ab as Alice B\nend \n\naa-&gt;&gt;sa: Request data export\nsa-&gt;&gt;aa: Data export\naa-&gt;ab: Data shared on device\nab-&gt;&gt;ab: Verify data integrity\nab-&gt;&gt;ab: Re-sign data\nab-&gt;&gt;sb: Request data import\nsb-&gt;&gt;sb: Verify data integrity\nsb-&gt;&gt;ab: Data import successful\naa-xsa: Deactivate account</code></pre>"},{"location":"Protocol%20Specifications/core/#glossary","title":"Glossary","text":"<ul> <li>Actor - An entity represented by a federation ID, registered on a home server. Actors can be users, bots, or any other entity with an identity.</li> <li>Client - Any application used by an actor to connect to a server.</li> <li>Federation ID - A unique identifier; In public contexts, usually <code>username@optionalsubdomain.domain.tld</code></li> <li>Foreign client - Any client authenticated on a server that is not its home server.</li> <li>Foreign server - A server that an actor is not registered on; essentially a third party.</li> <li>Home client - Any client registered and authenticated on its home server.</li> <li>Home server - The server that an actor is registered on. Any polyproto-core compliant server hosted on the same domain is also considered a home server.</li> <li>Identity - A unique Federation ID.</li> <li>Identity Key - A key pair representing an actor's identity in a session, used for signing and encrypting messages.</li> <li>Instance - A server hosting polyproto compliant software for clients.</li> <li>polyproto-chat - The chat-API used by Polyphony. An extension of the polyproto protocol, defining the routes and capabilities of the chat-API used by Polyphony.</li> <li>polyproto - The core federation protocol and APIs of polyproto, enabling identification and authorization on 'foreign' servers. It is independent of the chat-API used.</li> <li>Root Certificate - A certificate used to sign other certificates, establishing a chain of trust. In polyproto, only home servers have root certificates.</li> <li>Session - A specific period of interaction between a client and a server, typically identified and authenticated by the use of an identity key. The session begins when the client connects to the server and ends when the client disconnects. During a session, the client can interact with the server (e.g., send messages, make requests) under the identity associated with the session.</li> </ul> <p>The below creation- and update-times are not accurate. This is only an issue on this page. Please have a look at the commit history to view when this document was last updated.</p>"},{"location":"blog/","title":"Blog","text":""},{"location":"blog/2023/08/17/self-updating-structs-moving-blog-posts-to-github-and-more/","title":"Self-updating structs, moving blog posts to GitHub, and more!","text":"<p>Introducing self-updating structs, explaining how they work, and what they are good for. Also, moving blog posts to GitHub, and other improvements.</p> <p>It has been a while since the last update post - 1 month to be precise! I haven't gotten around to writing one of these, mostly because of personal time- and energy constraints. However, now that these resources are finally replenishing again, I figured that it is once again time!</p>"},{"location":"blog/2023/08/17/self-updating-structs-moving-blog-posts-to-github-and-more/#moving-blog-posts-to-github","title":"Moving Blog Posts to GitHub","text":"<p>This is a pretty self-explanatory point. I thought, that opencollective would find more use by me and other polyphony-curious folk, however, this didn't go as planned. Also, opencollective made their Discord embeds really poopy, which is why I am moving all the blog posts over to GitHub.</p>"},{"location":"blog/2023/08/17/self-updating-structs-moving-blog-posts-to-github-and-more/#a-big-one-self-updating-structs","title":"A big one: Self-updating structs","text":"<p>Ideally, you want entities like Channels, Guilds, or Users to react to Gateway events. A Gateway event is basically a message from Spacebar/Discord to you, which says: \"Hey, User <code>x</code> has changed their name to <code>y</code>!\". If you can reflect those changes immediately within your code, you save yourself from having to make a lot of requests and potentially getting rate-limited.</p> <p>This is exactly what Self-updating structs set out to solve. The first implementation was done by @SpecificProtagonist and me (thank you a lot again, btw) on the 21st of July. However: This implementation, being in its' infancy, has had some design flaws, which to me made pretty clear, that this whole thing needed to be thought through a little better.</p> <p>The second iteration of these Self-updating structs was finished... today, actually, by me. It saves memory compared to the first iteration by storing unique objects only once, instead of <code>n = how many times they are being referenced</code>-times. While this way of doing things is really efficient, it also has been a pain in the ass to make, which is precisely the reason why this took me so long. I've learned a lot along the way though.</p> <p>The public API has also gotten a lot better in \"v2\". This is mostly because I am a big believer in writing tests for your code, and through writing what are essentialy real-world-simulation-examples, I noticed how repetitive or stupid some things were, and thus could improve upon them.</p> <p>Having this whole thing finished is a big relief. This self-updating thing is an essential feature for any Discord/Spacebar compatible library, and I think that we implemented it very nicely.</p>"},{"location":"blog/2023/08/17/self-updating-structs-moving-blog-posts-to-github-and-more/#documentation-and-other-improvements","title":"Documentation and other improvements","text":"<p>@kozabrada123 took it upon himself to re-write a lot of the codes' Documentation. Thanks for that! This will massively improve the ease of use of this library - both when developing for and with it. koza also improved our CI/CT pipeline by incorporating build-caching into it, which speeds up builds.</p> <p>This has been the last month of Polyphony. In the coming weeks, I will be working on - Implementing self-updating-struct behavior for every struct which needs it - Fixing bugs - Adding more features, like emojis, 2FA, Guild Settings, etc.!</p> <p>See ya next time!</p>"},{"location":"blog/2023/08/29/chorus-alpha-010/","title":"chorus Alpha 0.1.0","text":"<p>We are alpha now! As of 2 days ago, the first Alpha of Chorus, Version 0.1.0, has been released for everyone to look at and use on crates.io!</p> <p>So, is the library complete now? No. And yes! It's, well, complicated... Let me explain!</p> <p>Chorus is at a point where I can comfortably say that, if you take voice-support out of the calculation for a bit, the foundation feels rock-solid, easy to work with and easily expandable. However, to stay with our house/building metaphor for a bit, the walls aren't painted yet, there's barely any furniture and not all of the electrical outlets have been installed yet.</p> <p>Okay, enough with this bad metaphor; What I meant to convey is, that a lot of the API endpoints have not yet been implemented, and there are at least a few points we haven't addressed yet - like Gateway Error Handling, to name an example.</p> <p>But for an early Alpha, this, in my opinion, is absolutely acceptable. Implementing API endpoints is something that probably someone who is entirely new to Rust could do, given that we've streamlined the procedure so much, and the other stuff can comfortably be fixed without having to do any major changes to the internals.</p> <p>I, for one, am currently experimenting around with the Polyphony Client, which, by the way, will likely be written with Iced as a GUI Framework, not GTK. I have no prior experience in GUI/Desktop Application development, but I am feeling more confident than ever and I'm eager to learn all there is to know about these topics.</p> <p>That's that! Seeya next time. Cheers,</p> <p>Flori</p>"},{"location":"blog/2023/09/02/getting-started-with-the-polyphony-client/","title":"Getting started with the Polyphony Client","text":"<p>Us labeling Chorus to be in a public-alpha state was really great news for me, for a lot of reasons! It marked a point in Polyphonys history where, after all these months of work, we agreed upon the fact that what we have is good enough to be shown to the public, and that's always a nice thing when investing so much of your free-time into a project.  The other main reason why this is such a great thing is, because this alpha state (at least to me) means, that the public API is kind-of stable, or at least stable enough so that I, the project lead, can rely upon the fact that all the public methods will not, in fact, be replaced in 4 days.</p> <p>This means, that I can finally start working on the Client! And I have done that! For the past 2? 3? Days, I've been tinkering around with Iced-rs (a really, really great UI framework for Rust, written in Rust) and the client repository to create the 'skeleton' of the application. While this is definitely not trivial, especially since I have no prior experience in desktop application development, it's also not too hard either.</p> <p>While Iced is not mature yet, and \"how-to\" guides, as well as the promised Iced-book, are still largely missing, the maintainers have done a great job with providing a LOT of code examples and solid rustdocs. It's a fun library/framework to work with, and the Elm-inspired approach of dividing up State, Messages, View- and Update-Logic feels really intuitive and seems to make sure that your Application will never end up in an unexpected state.</p> <p>That's all I have for today. Thanks for reading this! Here's a video of multi-user login already working ^^</p>"},{"location":"blog/2023/11/23/porting-chorus-to-webassembly--client-update/","title":"Porting chorus to WebAssembly + Client Update","text":"<p>What the current state of GUI libraries in Rust means for Polyphony and chorus, and why we are porting chorus to WebAssembly.</p> <p>Hi all!</p> <p>To make this part of the post short: The web-based client will be worked on before the native one, if there even ever will be one. The reason is that no currently available native Rust GUI library meets the standards I'd like to see when using it to build an application I am putting my name behind. I'd like to have - accessibility - great styling - cross compilation - memory safety</p> <p>and the current state of Rust GUIs essentially tells me to \"pick three\", which is unacceptable to me. A WebAssembly based application is the best we'll get for now, and I am fine with that.</p> <p>Compiling to WebAssembly isn't all that easy though: The <code>wasm32-unknown-unknown</code> target intentionally makes no assumptions about the environment it is deployed in, and therefore does not provide things like a <code>net</code> or <code>filesystem</code> implementation (amongst other things). Luckily, adding support for this compilation target only took me a full 40h work week [:)], and we are now the first Rust Discord-API library (that I know of) to support this target.</p> <p>You might not have yet heard much about WebAssembly: In the past, web developers could only really use three languages - HTML, CSS, and JavaScript - to write code that browsers could understand directly. With WebAssembly, developers can write code in many other languages, then use WASM to convert it into a form the browser can run.</p> <p>This is particularly helpful for programs that require a lot of computing power, like video games or design software. Before, running such programs in a browser would be slow or impossible. WebAssembly can make these run smoothly, right in your web browser.</p> <p>Overall, WebAssembly is expanding the kinds of applications that can be run on the web, making the web a more flexible and powerful place to work and play. Compiling Chorus for WASM allows us to leverage this fairly new technology and bring all of Rusts benefits into a web context.</p> <p>The next blog post will likely be about progress with the web-based client. See ya until then! :)</p>"},{"location":"blog/2024/02/07/account-migration-in-polyproto/","title":"Account migration in polyproto","text":"<p>Account migration is an important and difficult thing to get right in federated systems. In this blog post, I will outline how I imagine account migration to work in polyproto, and what benefits this approach brings.</p>"},{"location":"blog/2024/02/07/account-migration-in-polyproto/#account-migration-in-polyproto","title":"Account migration in polyproto","text":"<p>It seems that striking a good balance between user experience, convenience and privacy has been a difficult task for many federated systems, when it comes to account migration. polyprotos' approach to how data is distributed and stored, and how identities are managed, makes it possible to have a very smooth and secure account migration process.</p>"},{"location":"blog/2024/02/07/account-migration-in-polyproto/#the-problem","title":"The problem","text":"<p>Using Mastodon as an example; When a user wants to move from one instance to another, they have to create a new account on the new instance, and follow all the people they were following on the old account. All the toots and other data from the old account are left behind, and you do not have a way of porting them over to the new account. This is a problem that has been around for a long time, and it is not just a problem with Mastodon, but with many other federated systems as well.</p>"},{"location":"blog/2024/02/07/account-migration-in-polyproto/#how-polyproto-works-briefly","title":"How polyproto works, briefly","text":"<p>In polyproto, your federation ID, e.g. <code>xenia@example.com</code>, is what identifies you. If you want to  use this identity on a client, your client will generate a key pair for a certificate signing request, and send this request to your home server. Given that you didn't provide any invalid data, your home server will sign the certificate, and send it back to you.</p> <p>Any data you send to anyone - be it a chat message, a social media post, or anything else - is signed using your private key. This signature can be verified by anyone using your public key, which is part of the certificate you received from your home server. To check a certificates' validity, you can ask the home server for its root certificate, and verify the signature on the certificate you received.</p> <p>This means:</p> <ul> <li>All the data you send is cryptographically tied to your identity</li> <li>Anyone can verify that the data was actually sent by you</li> <li>Anyone can verify that the data was not tampered with by anyone else</li> <li>Everybody can verify that you are who you say you are</li> </ul> <p>This is even true when you are sending data to a different server than your home server. </p>"},{"location":"blog/2024/02/07/account-migration-in-polyproto/#migrating-an-account-on-polyproto","title":"Migrating an account on polyproto","text":""},{"location":"blog/2024/02/07/account-migration-in-polyproto/#low-data-centralization","title":"Low data centralization","text":"<p>Fundamentally, the process of migrating an account in polyproto relies mostly on changing data ownership, rather than moving data around. This works best in scenarios where data is highly distributed, and not stored in a central location.</p> <p>Example</p> <p>This might be the case in a social chat messaging system similar to Discord, where messages are stored on the servers of the people hosting the chat rooms.</p> <p>When you want to move your account from one server to another, you:</p> <ol> <li>First, create a new account on the new server</li> <li>Then, you configure the new account to back-reference the old account</li> <li>Next, if you are able to, you tell your old home server about the move</li> <li>Last but not least, you verify to the servers storing your data that you are the same person as   the one who created the old account. The servers then update the data ownership to your new account.   This is done by using your old private key(s), in a way that does not reveal your private key(s) to   anyone else. </li> </ol> <p>If applicable, your friends and followers will also be notified about the move, keeping existing relationships intact.</p> <p>Note</p> <p>This entire process does not rely on the old server being online. This means that the process can be completed even if the old server is down, or if the old server is not cooperating with the user. </p> <p>However, including the homeserver in the process adds to the general user experience. If you, for example, have included your federation ID as part of another, non-polyproto social media profile, the old server can automatically refer people to the new account.</p>"},{"location":"blog/2024/02/07/account-migration-in-polyproto/#moving-data","title":"Moving data","text":"<p>Should data actually need to be moved, for example when the old server is going to be shut down, or if the centralization of data is higher, the migration process is extended by a few steps:</p> <ol> <li>Using the old account, your client requests a data export from your old home server.</li> <li>The old home server sends you a data export. Your client will check the signatures on the exported    data, to make sure that the data was not tampered with.</li> <li>You then import the data into your new account on the new home server.</li> <li></li> </ol>"},{"location":"blog/2024/02/07/account-migration-in-polyproto/#conclusion","title":"Conclusion","text":"<p>polyproto's approach to account migration is very user-friendly, and does not require the user to do anything that is not already part of the normal usage of the system. The process is also very secure, as it relies on the cryptographic properties of X.509 certificates, and also works across a highly distributed data model, which, in my opinion, is how the internet should be.</p> <p>The biggest drawback to this approach is that there are a whole lot of web requests involved.  Depending on the amount of data, this can take some minutes or possibly even hours.</p> <p>It is also worth noting that all of this does not require any new or young technology. polyproto relies on X.509 certificates, which have been around for a  long time, and are widely used in many different applications. This means that the technology is well understood, and that there are already many great tools in all sorts of programming languages available to work with it. From my point of view, there is no need to reinvent the wheel.</p> <p>I hope that this article has given you a good understanding of how account migration works in polyproto. If you have any questions or feedback, feel free to reach out to me via E-Mail, where I can be reached under <code>flori@polyphony.chat</code>. OpenPGP is supported, and my public key can be found on keys.openpgp.org (click to download pubkey)</p>"},{"location":"blog/archive/2024/","title":"February 2024","text":""},{"location":"blog/archive/2023/","title":"November 2023","text":""},{"location":"blog/category/polyproto/","title":"polyproto","text":""},{"location":"blog/category/chorus/","title":"chorus","text":""},{"location":"blog/category/polyphony/","title":"polyphony","text":""}]}